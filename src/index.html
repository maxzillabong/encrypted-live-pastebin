<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Collab - E2E</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --panel: #16213e;
      --border: #0f3460;
      --accent: #e94560;
      --text: #eee;
      --muted: #94a3b8;
      --success: #22c55e;
      --warning: #f59e0b;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 1rem;
    }
    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .room-url {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      color: var(--muted);
      font-family: monospace;
      font-size: 0.875rem;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 400px;
    }
    .room-url:hover { background: var(--border); }
    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }
    .status-dot.offline { background: var(--accent); }
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .btn:hover { opacity: 0.9; }
    .btn-secondary { background: var(--border); }
    .toolbar {
      display: flex;
      align-items: center;
      padding: 0.5rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 0.75rem;
    }
    .toolbar select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
    }
    .version-badge {
      margin-left: auto;
      font-size: 0.75rem;
      color: var(--muted);
      background: var(--bg);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }
    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    .sidebar {
      width: 280px;
      min-width: 150px;
      max-width: 600px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .sidebar-resize {
      position: absolute;
      top: 0;
      right: 0;
      width: 4px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      z-index: 10;
    }
    .sidebar-resize:hover, .sidebar-resize.dragging {
      background: var(--accent);
    }
    .file-tree {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .tree-item {
      display: flex;
      align-items: center;
      padding: 0.375rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      gap: 0.5rem;
    }
    .tree-item:hover { background: var(--border); }
    .tree-item.selected { background: var(--accent); }
    .tree-item.folder { font-weight: 500; }
    .tree-item.non-syncable { color: var(--muted); opacity: 0.7; }
    .tree-item .icon { width: 16px; text-align: center; }
    .tree-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .tree-item .size { font-size: 0.75rem; color: var(--muted); }
    .tree-children { padding-left: 1rem; }
    .sidebar-actions {
      padding: 0.75rem;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .sidebar-actions button { width: 100%; justify-content: center; }
    .editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .file-header {
      padding: 0.75rem 1rem;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      font-family: monospace;
      font-size: 0.875rem;
      color: var(--muted);
    }
    .editor-container {
      flex: 1;
      overflow: auto;
      position: relative;
    }
    .editor {
      width: 100%;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      border: none;
      resize: none;
      padding: 1rem;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
      tab-size: 2;
      outline: none;
    }
    .CodeMirror {
      height: 100% !important;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .editor-container .CodeMirror {
      background: var(--bg);
    }
    .code-view {
      padding: 1rem;
      margin: 0;
      overflow: auto;
      height: 100%;
    }
    .code-view code {
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      gap: 1rem;
    }
    .empty-state h2 { font-size: 1.5rem; color: var(--text); }
    .empty-state p { max-width: 400px; text-align: center; line-height: 1.5; }
    .changeset-banner {
      background: var(--warning);
      color: #000;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .changeset-banner .message { flex: 1; font-weight: 500; }
    .changeset-banner .btn { background: #000; color: var(--warning); }
    .diff-view {
      padding: 1rem;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow: auto;
    }
    .diff-line { padding: 0 0.5rem; }
    .diff-line.added { background: rgba(34, 197, 94, 0.2); color: var(--success); }
    .diff-line.removed { background: rgba(233, 69, 96, 0.2); color: var(--accent); }
    .diff-line.header { color: var(--muted); }
    .change-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      margin: 1rem;
      overflow: hidden;
    }
    .change-card-header {
      background: var(--panel);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      border-bottom: 1px solid var(--border);
    }
    .change-card-header .path { flex: 1; font-family: monospace; font-size: 0.875rem; }
    .change-card-actions { display: flex; gap: 0.5rem; }
    .change-card-actions .btn { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
    }
    .modal h3 { margin-bottom: 1rem; }
    .modal input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    .modal-actions { display: flex; gap: 0.75rem; justify-content: flex-end; }
    .hidden { display: none !important; }
    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      z-index: 200;
      animation: slideIn 0.2s ease;
    }
    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--accent); }
    @keyframes slideIn {
      from { transform: translateY(1rem); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo"><span>&#128274;</span><span>Live Collab</span></div>
    <div class="room-url" id="roomUrl" onclick="copyRoomUrl()"></div>
    <button class="btn" onclick="copyRoomUrl()">Share</button>
    <button class="btn btn-secondary" onclick="showQRCode()" title="QR code (for browser isolation)">QR</button>
    <button class="btn btn-secondary" id="passwordBtn" onclick="showSetPasswordModal()" title="Set room password">&#128272;</button>
    <button class="btn btn-danger" onclick="confirmKillRoom()" title="Delete Room" style="background:#e94560;color:white;border:none">&#128163;</button>
    <div class="status">
      <span id="isolationWarning" style="display:none;background:#e94560;color:white;padding:2px 6px;border-radius:4px;font-size:0.75rem;cursor:pointer" onclick="runComprehensiveIsolationCheck()" title="Browser isolation detected - click for detailed analysis">ISOLATED</span>
      <span id="passwordStatus" style="display:none">&#128274;</span>
      <span id="stegoToggle" onclick="toggleStegoMode()" style="background:#22c55e;color:white;padding:2px 6px;border-radius:4px;font-size:0.75rem;cursor:pointer" title="Steganographic HTML encoding enabled - click to toggle">STEGO</span>
      <span>&#128274; E2E</span>
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Online</span>
    </div>
  </header>

  <div class="toolbar">
    <input type="text" id="fileSearch" placeholder="Search files..." oninput="filterFiles()" style="background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:0.375rem 0.5rem;color:var(--text);font-size:0.875rem;width:200px;">
    <button class="btn btn-secondary" onclick="copyCode()">Copy</button>
    <button class="btn btn-secondary" onclick="downloadAll()">Download All</button>
    <div class="version-badge">v<span id="versionBadge">0</span></div>
  </div>

  <div id="changesetBanner" class="changeset-banner hidden">
    <span class="message" id="changesetMessage"></span>
    <button class="btn" onclick="acceptAllChanges()">&#10003; Accept All</button>
    <button class="btn btn-secondary" onclick="rejectAllChanges()">&#10007; Reject All</button>
  </div>

  <main>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-resize" id="sidebarResize"></div>
      <div style="display:flex;gap:0.5rem;padding:0.5rem;border-bottom:1px solid var(--border)">
        <button class="btn btn-secondary" onclick="expandAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Expand All">&#9660; Expand</button>
        <button class="btn btn-secondary" onclick="collapseAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Collapse All">&#9654; Collapse</button>
      </div>
      <div class="file-tree" id="fileTree"></div>
      <div class="sidebar-actions">
        <button class="btn btn-secondary" onclick="showAddFileModal()">+ Add File</button>
        <button class="btn btn-secondary" onclick="showAddDirModal()">+ Add Directory</button>
        <button class="btn btn-secondary" onclick="uploadFolder()">&#128193; Upload Folder</button>
        <button class="btn btn-secondary" id="saveToDiskBtn" onclick="saveToDisk()" style="display:none">&#128190; Save to Disk</button>
        <input type="file" id="folderInput" webkitdirectory multiple style="display:none" onchange="handleFolderUpload(event)">
      </div>
    </aside>

    <section class="editor-panel">
      <div class="file-header" id="fileHeader">No file selected</div>
      <div class="editor-container" id="editorContainer">
        <div class="empty-state" id="emptyState">
          <h2>&#128274; Live Collab</h2>
          <p>E2E real-time collab. Upload a folder or create a file to get started.</p>
        </div>
        <div id="editorWrapper" class="hidden" style="height:100%"></div>
        <div class="diff-view hidden" id="diffView"></div>
      </div>
    </section>
  </main>

  <div id="addFileModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddFileModal()">
    <div class="modal">
      <h3>Add New File</h3>
      <input type="text" id="newFilePath" placeholder="path/to/file.js" onkeydown="if(event.key==='Enter')createNewFile()">
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddFileModal()">Cancel</button>
        <button class="btn" onclick="createNewFile()">Create</button>
      </div>
    </div>
  </div>

  <div id="addDirModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddDirModal()">
    <div class="modal">
      <h3>Add New Directory</h3>
      <input type="text" id="newDirPath" placeholder="path/to/directory" onkeydown="if(event.key==='Enter')createNewDir()">
      <p style="font-size:0.75rem;color:var(--muted);margin-top:0.5rem">Creates an empty .gitkeep file in the directory</p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddDirModal()">Cancel</button>
        <button class="btn" onclick="createNewDir()">Create</button>
      </div>
    </div>
  </div>

  <div id="passwordModal" class="modal-overlay hidden">
    <div class="modal">
      <h3 id="passwordModalTitle">Enter Room Password</h3>
      <input type="password" id="passwordInput" placeholder="Password" onkeydown="if(event.key==='Enter')submitPassword()">
      <p id="passwordError" style="color:var(--accent);font-size:0.875rem;margin-bottom:1rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn" onclick="submitPassword()">Enter</button>
      </div>
    </div>
  </div>

  <div id="setPasswordModal" class="modal-overlay hidden" onclick="if(event.target===this)hideSetPasswordModal()">
    <div class="modal">
      <h3>Set Room Password</h3>
      <p style="font-size:0.875rem;color:var(--muted);margin-bottom:1rem">Protect this room with a password. Others will need it to access.</p>
      <input type="password" id="setPasswordInput" placeholder="New password (min 4 chars)" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <input type="password" id="setPasswordConfirm" placeholder="Confirm password" style="margin-top:0.5rem" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <p id="setPasswordError" style="color:var(--accent);font-size:0.875rem;margin-top:0.5rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideSetPasswordModal()">Cancel</button>
        <button class="btn" onclick="setRoomPassword()">Set Password</button>
      </div>
    </div>
  </div>

  <div id="qrModal" class="modal-overlay hidden" onclick="if(event.target===this)hideQRCode()">
    <div class="modal" style="text-align:center;max-width:360px">
      <h3>Scan to Share</h3>
      <p style="font-size:0.875rem;color:var(--muted);margin-bottom:1rem">Use this if copy/paste is blocked (browser isolation)</p>
      <div id="qrCode" style="background:white;padding:1rem;border-radius:8px;display:inline-block"></div>
      <p style="font-size:0.75rem;color:var(--muted);margin-top:1rem;word-break:break-all" id="qrUrlDisplay"></p>
      <div class="modal-actions" style="margin-top:1rem">
        <button class="btn btn-secondary" onclick="hideQRCode()">Close</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/go/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/rust/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/ruby/ruby.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/php/php.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/swift/swift.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script>
    const roomId = window.location.pathname.split('/').pop();
    let encryptionKey = null;
    let cryptoKey = null;
    let version = 0;
    let files = [];
    let changesets = [];
    let selectedFile = null;
    let dirHandle = null;
    let isPolling = false;
    let saveTimeout = null;
    let lastActivityTime = 0;
    const POLLING_PAUSE_MS = 2000; // Pause polling for 2s after typing
    let cmEditor = null; // CodeMirror instance
    let roomPassword = sessionStorage.getItem('room_password_' + roomId) || '';
    let hasPassword = false;

    // === Operation-based sync (tiny deltas for Zscaler stealth) ===
    let opSeq = 0;                    // Current operation sequence from server
    let pendingOps = [];              // Ops waiting to be sent
    let isApplyingRemoteOps = false;  // Flag to prevent echo
    let opSendTimeout = null;         // Debounce for batching local ops
    const OP_SEND_DELAY = 100;        // Batch ops within 100ms
    const OP_POLL_INTERVAL = 1000;    // Poll for ops every 1s (faster than full state poll)
    const SNAPSHOT_THRESHOLD = 50;    // Snapshot after 50 ops
    let opsSinceSnapshot = 0;         // Counter for snapshot trigger
    let opPollInterval = null;        // Operation polling interval

    // === API Disguise Layer ===
    // Routes masquerade as a document management app to avoid detection
    const USE_DISGUISED_API = true;
    
    // === Traffic Obfuscation ===
    const STANDARD_SIZES = [256, 512, 1024, 2048, 4096, 8192, 16384];
    
    function randomJitter(min, max) {
      return new Promise(resolve => setTimeout(resolve, min + Math.random() * (max - min)));
    }

    function generatePadding(length) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function padPayload(data) {
      if (!data) return data;
      try {
        // Add decoy fields first
        const payload = {
          ...data,
          _analytics: {
            session_id: generateClientId(),
            view_time: Math.floor(performance.now()),
            scroll_depth: Math.random(),
            interaction_count: Math.floor(Math.random() * 50)
          },
          _meta: {
            client_ts: Date.now(),
            tz_offset: new Date().getTimezoneOffset()
          }
        };

        const json = JSON.stringify(payload);
        const len = new TextEncoder().encode(json).length;
        const targetSize = STANDARD_SIZES.find(s => s > len + 50) || (len + 1024);
        const padLen = Math.max(0, targetSize - len - 20);
        
        if (padLen > 0) {
          payload._pad = generatePadding(padLen);
        }
        return payload;
      } catch (e) {
        return data;
      }
    }

    function getDecoyHeaders() {
      return {
        'X-Client-Version': '2.4.1',
        'X-Request-ID': 'req_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
        'X-Session-Start': sessionStorage.getItem('session_start') || Date.now().toString(),
        'X-Feature-Flags': 'darkmode,neweditor,v2api,realtime_cursors',
        'X-Device-Type': 'desktop',
        'X-Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone
      };
    }

    // Initialize session start
    if (!sessionStorage.getItem('session_start')) {
      sessionStorage.setItem('session_start', Date.now().toString());
    }

    const BIP39_WORDS=["abandon",'ability','able','about','above','absent','absorb','abstract','absurd','abuse',
      'access','accident','account','accuse','achieve','acid','acoustic','acquire','across','act',
      'action','actor','actress','actual','adapt','add','addict','address','adjust','admit',
      'adult','advance','advice','aerobic','affair','afford','afraid','again','age','agent',
      'agree','ahead','aim','air','airport','aisle','alarm','album','alcohol','alert',
      'alien','all','alley','allow','almost','alone','alpha','already','also','alter',
      'always','amateur','amazing','among','amount','amused','analyst','anchor','ancient','anger',
      'angle','angry','animal','ankle','announce','annual','another','answer','antenna','antique',
      'anxiety','any','apart','apology','appear','apple','approve','april','arch','arctic',
      'area','arena','argue','arm','armed','armor','army','around','arrange','arrest',
      'arrive','arrow','art','artefact','artist','artwork','ask','aspect','assault','asset',
      'assist','assume','asthma','athlete','atom','attack','attend','attitude','attract','auction',
      'audit','august','aunt','author','auto','autumn','average','avocado','avoid','awake',
      'aware','away','awesome','awful','awkward','axis','baby','bachelor','bacon','badge',
      'bag','balance','balcony','ball','bamboo','banana','banner','bar','barely','bargain',
      'barrel','base','basic','basket','battle','beach','bean','beauty','become','beef',
      'before','begin','behave','behind','believe','below','belt','bench','benefit','best',
      'betray','better','between','beyond','bicycle','bid','bike','bind','biology','bird',
      'birth','bitter','black','blade','blame','blanket','blast','bleak','bless','blind',
      'blood','blossom','blouse','blue','blur','blush','board','boat','body','boil',
      'bomb','bone','bonus','book','boost','border','boring','borrow','boss','bottom',
      'bounce','box','boy','bracket','brain','brand','brass','brave','bread','breeze',
      'brick','bridge','brief','bright','bring','brisk','broccoli','broken','bronze','broom',
      'brother','brown','brush','bubble','buddy','budget','buffalo','build','bulb','bulk',
      'bullet','bundle','bunker','burden','burger','burst','bus','business','busy','butter'
    ];

    // Encode key bytes as BIP39-style word sequence
    function keyToWords(keyBase64) {
      const bytes = Uint8Array.from(atob(keyBase64.replace(/-/g, '+').replace(/_/g, '/') + '='), c => c.charCodeAt(0));
      const words = [];
      for (let i = 0; i < bytes.length; i += 2) {
        const idx = (bytes[i] << 3) | (bytes[i + 1] >> 5);
        words.push(BIP39_WORDS[idx % BIP39_WORDS.length]);
      }
      return words.slice(0, 8).join('-');
    }

    // Decode BIP39-style word sequence back to key
    function wordsToKey(wordString) {
      const words = wordString.split('-');
      const bytes = new Uint8Array(32);
      for (let i = 0; i < words.length && i < 16; i++) {
        const idx = BIP39_WORDS.indexOf(words[i].toLowerCase());
        if (idx === -1) return null;
        const byteIdx = i * 2;
        bytes[byteIdx] = (idx >> 3) & 0xFF;
        if (byteIdx + 1 < 32) bytes[byteIdx + 1] = ((idx & 0x07) << 5) | (bytes[byteIdx + 1] & 0x1F);
      }
      return btoa(String.fromCharCode(...bytes)).replace(/[+\/=]/g, c => c === '+' ? '-' : c === '/' ? '_' : '').slice(0, 43);
    }

    // === Steganographic HTML Encoding ===
    // Hide encrypted content in innocent-looking HTML attributes
    // Multiple format variants to prevent pattern detection

    const STEGO_CHUNK_SIZE = 4; // bytes per chunk
    let USE_STEGO_ENCODING = true; // Enable steganographic encoding

    // Format variant definitions - each mimics different SaaS patterns
    const STEGO_FORMATS = {
      // Analytics/tracking style
      analytics: {
        attrs: ['ref', 'sid', 'utm', 'cid', 'hash', 'src', 'rev', 'tag'],
        elementClass: 'embed-meta',
        wrapper: (hex, attr) => `<span class="embed-meta" data-${attr}="${hex}" data-v="2.1"></span>`
      },
      // CMS/content management style
      cms: {
        attrs: ['block', 'node', 'asset', 'media', 'link', 'slot', 'zone', 'part'],
        elementClass: 'content-block',
        wrapper: (hex, attr) => `<div class="content-block" data-${attr}-id="${hex}"></div>`
      },
      // Social media widget style
      social: {
        attrs: ['post', 'user', 'thread', 'reply', 'share', 'react', 'view', 'card'],
        elementClass: 'social-embed',
        wrapper: (hex, attr) => `<span class="social-embed" data-${attr}="${hex}" data-type="inline"></span>`
      },
      // E-commerce/product style
      ecommerce: {
        attrs: ['sku', 'item', 'price', 'stock', 'variant', 'option', 'cart', 'wish'],
        elementClass: 'product-ref',
        wrapper: (hex, attr) => `<span class="product-ref" data-${attr}="${hex}" data-currency="USD"></span>`
      }
    };

    // All possible attribute names across all formats (for decoding)
    const STEGO_ALL_ATTRS = [
      'ref', 'sid', 'utm', 'cid', 'hash', 'src', 'rev', 'tag',
      'block-id', 'node-id', 'asset-id', 'media-id', 'link-id', 'slot-id', 'zone-id', 'part-id',
      'post', 'user', 'thread', 'reply', 'share', 'react', 'view', 'card',
      'sku', 'item', 'price', 'stock', 'variant', 'option', 'cart', 'wish'
    ];

    // Cover text variants - randomly selected for natural variation
    const STEGO_COVER_TEXTS = [
      'Document content synchronized.',
      'Content has been updated.',
      'Changes saved successfully.',
      'Last revision loaded.',
      'Syncing workspace data...',
      'Document ready.',
      'Content loaded from server.',
      'Workspace synchronized.'
    ];

    function uint8ArrayToHex(array) {
      return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function hexToUint8Array(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    // Randomly select a format for this encryption
    function selectStegoFormat() {
      const formats = ['analytics', 'cms', 'social', 'ecommerce'];
      return formats[Math.floor(Math.random() * formats.length)];
    }

    // Encode ciphertext bytes as HTML with data attributes
    function stegoChunkEncode(data, format) {
      const selectedFormat = format || selectStegoFormat();
      const config = STEGO_FORMATS[selectedFormat];
      const chunks = [];

      for (let i = 0; i < data.length; i += STEGO_CHUNK_SIZE) {
        const chunk = data.slice(i, i + STEGO_CHUNK_SIZE);
        const hex = uint8ArrayToHex(chunk);
        const attr = config.attrs[chunks.length % config.attrs.length];
        chunks.push(config.wrapper(hex, attr));
      }

      return chunks.join('\n');
    }

    // Build regex pattern for all supported attribute formats
    function buildStegoDecodeRegex() {
      const attrPattern = STEGO_ALL_ATTRS.map(a => a.replace('-', '\\-')).join('|');
      return new RegExp(`data-(?:${attrPattern})="([a-f0-9]+)"`, 'g');
    }

    // Decode ciphertext from HTML data attributes (supports all formats)
    function stegoChunkDecode(html) {
      const regex = buildStegoDecodeRegex();
      const chunks = [];
      let match;

      while ((match = regex.exec(html)) !== null) {
        chunks.push(hexToUint8Array(match[1]));
      }

      // Concatenate all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;

      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }

      return result;
    }

    // Wrap encrypted content in innocent-looking document markup
    function stegoWrapContent(ivHex, encodedChunks, coverText) {
      const timestamp = Date.now();
      const selectedCover = coverText || STEGO_COVER_TEXTS[Math.floor(Math.random() * STEGO_COVER_TEXTS.length)];
      const revNumber = Math.floor(Math.random() * 10) + 1;

      return `<div class="doc-content" data-rev="${revNumber}" data-sync="${timestamp}">
  <p>${selectedCover}</p>
  <div class="embed-section" data-iv="${ivHex}">
${encodedChunks}
  </div>
  <footer class="doc-footer">
    <span class="ts">Last updated</span>
  </footer>
</div>`;
    }

    // Extract encrypted content from document markup
    function stegoUnwrapContent(html) {
      // Extract IV
      const ivMatch = html.match(/data-iv="([^"]+)"/);
      if (!ivMatch) return null;

      // Extract and decode chunks
      const data = stegoChunkDecode(html);
      if (data.length === 0) return null;

      return {
        iv: ivMatch[1],
        data: data
      };
    }

    // Check if content appears to be stego-encoded HTML
    function isStegoEncodedContent(content) {
      if (!content || typeof content !== 'string') return false;
      if (!content.includes('data-iv="')) return false;

      // Check for any of the chunk format patterns
      const hasAnalytics = /data-(?:ref|sid|utm|cid|hash|src|rev|tag)="[a-f0-9]+"/.test(content);
      const hasCms = /data-(?:block|node|asset|media|link|slot|zone|part)-id="[a-f0-9]+"/.test(content);
      const hasSocial = /data-(?:post|user|thread|reply|share|react|view|card)="[a-f0-9]+"/.test(content);
      const hasEcommerce = /data-(?:sku|item|price|stock|variant|option|cart|wish)="[a-f0-9]+"/.test(content);

      return hasAnalytics || hasCms || hasSocial || hasEcommerce;
    }

    // High-level: Encode base64 ciphertext to stego HTML
    function stegoEncode(base64Ciphertext) {
      if (!USE_STEGO_ENCODING) return base64Ciphertext;

      // Convert base64 to bytes
      const data = Uint8Array.from(atob(base64Ciphertext), c => c.charCodeAt(0));

      // IV is first 12 bytes
      const iv = data.slice(0, 12);
      const ciphertext = data.slice(12);

      // Encode chunks
      const encodedChunks = stegoChunkEncode(ciphertext);

      // Wrap in HTML
      return stegoWrapContent(uint8ArrayToHex(iv), encodedChunks);
    }

    // High-level: Decode stego HTML back to base64 ciphertext
    function stegoDecode(html) {
      if (!isStegoEncodedContent(html)) return html; // Return as-is if not stego-encoded

      const unwrapped = stegoUnwrapContent(html);
      if (!unwrapped) return html;

      // Reconstruct: IV (from hex) + ciphertext
      const iv = hexToUint8Array(unwrapped.iv);
      const combined = new Uint8Array(iv.length + unwrapped.data.length);
      combined.set(iv);
      combined.set(unwrapped.data, iv.length);

      // Convert back to base64
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < combined.length; i += chunkSize) {
        binary += String.fromCharCode(...combined.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }

    // API endpoint mapping for disguise mode
    const API = {
      roomState: (since = 0, limit = 1000, offset = 0) => {
        const params = `?since=${since}&limit=${limit}&offset=${offset}`;
        return USE_DISGUISED_API 
          ? `/api/workspace/${roomId}${params}` 
          : `/api/room/${roomId}${params}`;
      },
      roomInfo: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/info` : `/api/room/${roomId}/info`,
      roomVersion: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/status` : `/api/room/${roomId}/version`,
      syncBegin: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/session` : `/api/room/${roomId}/sync/begin`,
      syncChunk: () => USE_DISGUISED_API ? `/api/documents/batch` : `/api/room/${roomId}/sync/chunk`,
      syncComplete: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/finalize` : `/api/room/${roomId}/sync/complete`,
      ops: () => USE_DISGUISED_API ? `/api/documents` : `/api/room/${roomId}/ops`,
      files: () => USE_DISGUISED_API ? `/api/documents/save` : `/api/room/${roomId}/files`,
      deleteRoom: () => `/api/room/${roomId}` // Keep original for admin actions
    };

    async function initEncryption() {
      const fragment = window.location.hash.slice(1);
      if (fragment && fragment.length >= 32) {
        encryptionKey = fragment;
      } else {
        const keyBytes = crypto.getRandomValues(new Uint8Array(32));
        encryptionKey = btoa(String.fromCharCode(...keyBytes)).replace(/[+\/=]/g, c =>
          c === '+' ? '-' : c === '/' ? '_' : ''
        ).slice(0, 43);
        window.location.hash = encryptionKey;
      }
      const keyData = Uint8Array.from(atob(encryptionKey.replace(/-/g, '+').replace(/_/g, '/') + '='), c => c.charCodeAt(0));
      cryptoKey = await crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt']);
      document.getElementById('roomUrl').textContent = window.location.href;
    }

    // Core encryption - returns base64
    async function encryptRaw(plaintext) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(plaintext);
      const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, encoded);
      const combined = new Uint8Array(iv.length + ciphertext.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(ciphertext), iv.length);
      // Convert to base64 in chunks to avoid stack overflow
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < combined.length; i += chunkSize) {
        binary += String.fromCharCode(...combined.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }

    // Encrypt with optional stego encoding
    async function encrypt(plaintext) {
      const base64 = await encryptRaw(plaintext);
      return USE_STEGO_ENCODING ? stegoEncode(base64) : base64;
    }

    // Core decryption - expects base64
    async function decryptRaw(base64) {
      if (!base64) return '';
      try {
        const data = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = data.slice(0, 12);
        const ciphertext = data.slice(12);
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext);
        return new TextDecoder().decode(plaintext);
      } catch (e) {
        console.error('Decryption failed:', e);
        return '[Decryption Error]';
      }
    }

    // Decrypt with auto-detection of stego encoding
    async function decrypt(encoded) {
      if (!encoded) return '';
      try {
        // Auto-detect and decode stego content
        const base64 = isStegoEncodedContent(encoded) ? stegoDecode(encoded) : encoded;
        return await decryptRaw(base64);
      } catch (e) {
        console.error('Decryption failed:', e);
        return '[Decryption Error]';
      }
    }

    // Hash path for deterministic lookups (SHA-256)
    async function hashPath(path) {
      const encoded = new TextEncoder().encode(path);
      const hashBuffer = await crypto.subtle.digest('SHA-256', encoded);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // === Operation functions (tiny deltas instead of full content) ===

    // Convert CodeMirror position to character offset
    function posToOffset(doc, pos) {
      let offset = 0;
      for (let i = 0; i < pos.line; i++) {
        offset += doc.getLine(i).length + 1; // +1 for newline
      }
      offset += pos.ch;
      return offset;
    }

    // Convert character offset to CodeMirror position
    function offsetToPos(doc, offset) {
      let remaining = offset;
      for (let line = 0; line < doc.lineCount(); line++) {
        const lineLength = doc.getLine(line).length + 1;
        if (remaining < lineLength) {
          return { line, ch: remaining };
        }
        remaining -= lineLength;
      }
      // Past end of doc
      const lastLine = doc.lineCount() - 1;
      return { line: lastLine, ch: doc.getLine(lastLine).length };
    }

    // Capture local edit and queue as operation
    function captureLocalOp(cm, change) {
      if (isApplyingRemoteOps) return; // Don't capture ops we're applying
      if (!selectedFile || !selectedFile.is_syncable) return;

      const doc = cm.getDoc();
      const pos = posToOffset(doc, change.from);
      const removedText = change.removed.join('\n');
      const insertedText = change.text.join('\n');

      const op = {
        file_path: selectedFile.path,
        pos: pos,
        del: removedText.length,
        ins: insertedText
      };

      pendingOps.push(op);
      scheduleSendOps();
    }

    // Schedule sending pending ops (debounced)
    function scheduleSendOps() {
      clearTimeout(opSendTimeout);
      opSendTimeout = setTimeout(sendPendingOps, OP_SEND_DELAY);
    }

    // Send pending ops to server
    async function sendPendingOps() {
      if (pendingOps.length === 0) return;

      const opsToSend = pendingOps.splice(0, pendingOps.length);
      const clientId = generateClientId();

      for (const op of opsToSend) {
        try {
          const pathHash = await hashPath(op.file_path);
          const opData = { pos: op.pos, del: op.del, ins: op.ins };
          const opEncrypted = await encrypt(JSON.stringify(opData));

          let url, body;
          if (USE_DISGUISED_API) {
            // Disguised as document edit
            url = `/api/documents/${pathHash}/edits`;
            body = {
              workspace_id: roomId,
              edit_data: opEncrypted,
              author_id: clientId,
              base_revision: selectedFile.version || 0
            };
          } else {
            url = '/api/room/' + roomId + '/ops';
            body = {
              file_path_hash: pathHash,
              delta: opEncrypted,
              client_id: clientId,
              base_version: selectedFile.version || 0,
              metadata: generateMetadata()
            };
          }

          const res = await apiFetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          if (res.ok) {
            const result = await res.json();
            opSeq = Math.max(opSeq, USE_DISGUISED_API ? result.revision : result.seq);
            opsSinceSnapshot++;

            // Trigger snapshot if needed
            if (opsSinceSnapshot >= SNAPSHOT_THRESHOLD) {
              await snapshotFile(selectedFile);
              opsSinceSnapshot = 0;
            }
          }
        } catch (e) {
          console.error('Failed to send op:', e);
          // Re-queue failed ops
          pendingOps.unshift(op);
        }
      }
    }

    // Poll for operations from other clients
    async function pollOps() {
      if (!selectedFile || !selectedFile.is_syncable) return;

      try {
        const pathHash = await hashPath(selectedFile.path);
        let url;
        if (USE_DISGUISED_API) {
          url = `/api/documents/${pathHash}/edits?workspace=${roomId}&since=${opSeq}`;
        } else {
          url = '/api/room/' + roomId + '/ops?since=' + opSeq + '&file=' + pathHash;
        }

        const res = await apiFetch(url);

        if (res.ok) {
          const data = await res.json();
          const clientId = generateClientId();

          // Apply ops from other clients (handle both API formats)
          const ops = USE_DISGUISED_API ? data.edits : data.ops;
          for (const op of ops) {
            const opClientId = USE_DISGUISED_API ? op.author_id : op.client_id;
            if (opClientId === clientId) continue; // Skip own ops

            try {
              const opEncrypted = USE_DISGUISED_API ? op.data : op.delta;
              const opData = JSON.parse(await decrypt(opEncrypted));
              applyRemoteOp(opData);
            } catch (e) {
              console.error('Failed to apply op:', e);
            }
          }

          opSeq = USE_DISGUISED_API ? data.current_revision : data.current_seq;
        }
      } catch (e) {
        console.error('Op poll error:', e);
      }
    }

    // Apply a remote operation to the editor
    function applyRemoteOp(op) {
      if (!cmEditor) return;

      isApplyingRemoteOps = true;
      try {
        const doc = cmEditor.getDoc();
        const from = offsetToPos(doc, op.pos);
        const to = offsetToPos(doc, op.pos + op.del);

        // Preserve cursor position
        const cursor = cmEditor.getCursor();
        const scrollInfo = cmEditor.getScrollInfo();

        cmEditor.replaceRange(op.ins, from, to, 'remote');

        // Restore cursor if it was after the edit
        cmEditor.setCursor(cursor);
        cmEditor.scrollTo(scrollInfo.left, scrollInfo.top);

        // Update local file content
        if (selectedFile) {
          selectedFile.content = cmEditor.getValue();
        }
      } finally {
        isApplyingRemoteOps = false;
      }
    }

    // Snapshot a file (compact ops into content)
    async function snapshotFile(file) {
      if (!file || !file.is_syncable) return;

      try {
        const pathHash = await hashPath(file.path);
        const contentEncrypted = await encrypt(file.content);

        const res = await apiFetch('/api/room/' + roomId + '/files/' + pathHash + '/snapshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            body: contentEncrypted,
            through_seq: opSeq,
            metadata: generateMetadata()
          })
        });

        if (res.ok) {
          console.log('Snapshot created for', file.path);
        }
      } catch (e) {
        console.error('Snapshot failed:', e);
      }
    }

    // Start operation polling for a file
    function startOpPolling() {
      stopOpPolling();
      opPollInterval = setInterval(pollOps, OP_POLL_INTERVAL);
    }

    // Stop operation polling
    function stopOpPolling() {
      if (opPollInterval) {
        clearInterval(opPollInterval);
        opPollInterval = null;
      }
    }

    const SYNCABLE_EXT = new Set(['.js','.ts','.jsx','.tsx','.mjs','.cjs','.py','.java','.kt','.go','.rs','.rb','.php','.swift','.c','.cpp','.h','.cs','.lua','.sh','.bash','.json','.yaml','.yml','.toml','.xml','.html','.htm','.css','.scss','.sass','.md','.mdx','.txt','.sql','.vue','.svelte','.env','.gitignore','.dockerfile']);
    const NEVER_SYNC_EXT = new Set(['.jar','.exe','.dll','.so','.o','.a','.pyc','.wasm','.zip','.tar','.gz','.rar','.7z','.png','.jpg','.jpeg','.gif','.ico','.svg','.webp','.mp3','.mp4','.wav','.avi','.mov','.woff','.woff2','.ttf','.otf','.pdf','.doc','.docx','.xls','.xlsx','.ppt','.db','.sqlite','.pem','.key','.crt']);
    const NEVER_SYNC_DIRS = new Set(['node_modules','.git','dist','build','out','target','__pycache__','.next','vendor','venv','.venv','coverage','.idea','.vscode']);

    // Simple gitignore pattern matcher
    let gitignorePatterns = [];

    function parseGitignore(content) {
      const patterns = [];
      for (const line of content.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) continue;
        try {
          let pattern = trimmed;
          let isNegation = pattern.startsWith('!');
          if (isNegation) pattern = pattern.slice(1);
          let isDir = pattern.endsWith('/');
          if (isDir) pattern = pattern.slice(0, -1);
          // Escape regex special chars
          pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          // Convert glob patterns back
          pattern = pattern.replace(/\\\*\\\*/g, '.*');
          pattern = pattern.replace(/\\\*/g, '[^/]*');
          pattern = pattern.replace(/\\\?/g, '.');
          // Handle patterns starting with /
          if (pattern.startsWith('\\/')) {
            pattern = '^' + pattern.slice(2);
          } else {
            pattern = '(^|/)' + pattern;
          }
          if (isDir) pattern += '(/|$)';
          else pattern += '($|/)';
          patterns.push({ regex: new RegExp(pattern), isNegation, isDir });
        } catch (e) {
          console.warn('Invalid gitignore pattern:', trimmed, e);
        }
      }
      return patterns;
    }

    function isGitignored(path) {
      let ignored = false;
      for (const { regex, isNegation } of gitignorePatterns) {
        if (regex.test(path)) {
          ignored = !isNegation;
        }
      }
      return ignored;
    }

    function getExtension(filename) {
      const parts = filename.split('.');
      return parts.length > 1 ? '.' + parts.pop().toLowerCase() : '';
    }

    function isInIgnoredDir(path) {
      const parts = path.split('/');
      return parts.some(p => NEVER_SYNC_DIRS.has(p));
    }

    function isSyncable(path, content) {
      if (isInIgnoredDir(path)) return false;
      const filename = path.split('/').pop();
      if (filename === '.DS_Store' || filename === 'Thumbs.db') return false;
      if (isGitignored(path)) return false;
      const ext = getExtension(path);
      if (NEVER_SYNC_EXT.has(ext)) return false;
      if (SYNCABLE_EXT.has(ext)) return true;
      if (content && typeof content === 'string') {
        // Check for binary content by looking for control characters
        const sample = content.slice(0, 8000);
        let controlCount = 0;
        for (let i = 0; i < sample.length; i++) {
          const code = sample.charCodeAt(i);
          if ((code >= 0 && code <= 8) || code === 11 || code === 12 || (code >= 14 && code <= 31)) {
            controlCount++;
          }
        }
        if (controlCount / Math.min(content.length, 8000) > 0.1) return false;
      }
      return true;
    }

    function detectLanguage(filename) {
      const ext = getExtension(filename);
      // CodeMirror mode names
      const map = {
        '.js': 'javascript', '.mjs': 'javascript', '.cjs': 'javascript', '.jsx': 'javascript',
        '.ts': 'text/typescript', '.tsx': 'text/typescript',
        '.py': 'python',
        '.java': 'text/x-java', '.kt': 'text/x-kotlin',
        '.cs': 'text/x-csharp', '.cpp': 'text/x-c++src', '.c': 'text/x-csrc', '.h': 'text/x-c++hdr',
        '.go': 'go', '.rs': 'rust', '.rb': 'ruby', '.php': 'php',
        '.swift': 'swift', '.sql': 'sql',
        '.html': 'htmlmixed', '.htm': 'htmlmixed',
        '.css': 'css', '.scss': 'css',
        '.json': 'application/json',
        '.yaml': 'yaml', '.yml': 'yaml',
        '.md': 'markdown', '.sh': 'shell', '.bash': 'shell',
        '.xml': 'xml', '.svg': 'xml'
      };
      return map[ext] || 'text/plain';
    }

    // Hash password before sending (Client-side protection)
    async function hashPassword(password) {
      if (!password) return '';
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // API fetch with password header
    // API fetch with password header + Obfuscation
    async function apiFetch(e, t = {}) {
      // 1. Request Timing Jitter
      await randomJitter(30, 150);

      const headers = { 
        ...t.headers,
        ...getDecoyHeaders() 
      };
      
      if (roomPassword) {
        headers["X-Room-Password"] = roomPassword;
      }

      // 2. Request Padding (for POST/PUT)
      let body = t.body;
      if (t.method && ['POST', 'PUT', 'PATCH'].includes(t.method.toUpperCase()) && body) {
        try {
          const data = JSON.parse(body);
          const padded = padPayload(data);
          body = JSON.stringify(padded);
        } catch (e) {
          // Ignore parsing errors (e.g. if body isn't JSON)
        }
      }

      const n = await fetch(e, { ...t, headers, body });
      
      if (401 === n.status && (await n.json()).password_required) {
        throw showPasswordModal(), new Error("Password required");
      }
      return n;
    }

    async function fetchRoomState() {
      let allFiles = [];
      let offset = 0;
      const LIMIT = 50; // Chunk size
      let hasMore = true;
      let initialData = null;

      while (hasMore) {
        // Fetch chunk
        const res = await apiFetch(API.roomState(0, LIMIT, offset));
        if (!res.ok) throw new Error('Failed to fetch room chunk');
        const data = await res.json();

        // Normalize if disguised
        let normalized;
        if (USE_DISGUISED_API) {
          normalized = {
            version: data.version,
            op_seq: data.op_seq,
            has_password: data.has_password,
            files: data.documents.map(d => ({
              id: d.id,
              path_hash: d.metadata?.refs?.[0],
              title: d.title,
              body: d.content,
              is_syncable: d.is_syncable,
              size_bytes: d.size_bytes,
              version: parseInt(d.metadata?.tracking?.utm_source) || 1
            })),
            changesets: data.proposals || [],
            has_more: data.has_more
          };
        } else {
          normalized = data;
        }

        if (offset === 0) initialData = normalized;
        allFiles.push(...normalized.files);
        
hasMore = normalized.has_more;
        offset += LIMIT;
        
        // Optional: could yield to UI here to show progress
        if (hasMore) {
           console.log(`Loaded ${allFiles.length} files...`);
           await new Promise(r => setTimeout(r, 50)); // Tiny delay to not block UI
        }
      }
      
      initialData.files = allFiles;
      return initialData;
    }

    async function checkRoomInfo() {
      const res = await fetch(API.roomInfo());
      if (!res.ok) throw new Error('Failed to get room info');
      const data = await res.json();
      // Normalize from disguised API
      if (USE_DISGUISED_API) {
        return { id: data.workspace_id, has_password: data.requires_auth };
      }
      return data;
    }

    async function saveFile(path, content, isSyncableFile) {
      if (isSyncableFile === undefined) isSyncableFile = true;
      const pathHash = await hashPath(path);
      const pathEnc = await encrypt(path);
      const contentEnc = isSyncableFile ? await encrypt(content) : null;

      let body;
      if (USE_DISGUISED_API) {
        // Disguised as document save
        body = {
          workspace_id: roomId,
          title: pathEnc,
          content: contentEnc,
          metadata: {
            refs: [pathHash],
            tracking: { utm_source: 'editor', utm_medium: 'direct' }
          },
          is_syncable: isSyncableFile,
          size_bytes: isSyncableFile ? null : content.length
        };
      } else {
        body = {
          path_hash: pathHash,
          title: pathEnc,
          body: contentEnc,
          is_syncable: isSyncableFile,
          size_bytes: isSyncableFile ? null : content.length
        };
      }

      const res = await apiFetch(API.files(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!res.ok) throw new Error('Failed to save file');
      return res.json();
    }

    async function deleteFile(fileId) {
      const res = await apiFetch('/api/room/' + roomId + '/files/' + fileId, { method: 'DELETE' });
      if (!res.ok) throw new Error('Failed to delete file');
    }

    // Stealth chunked sync - designed for enterprise proxy compatibility
    const CHUNK_TARGET_SIZE = 150 * 1024; // ~150KB per chunk (well under DLP thresholds)
    const CHUNK_MIN_DELAY = 200;  // Min delay between chunks (ms)
    const CHUNK_MAX_DELAY = 800;  // Max delay between chunks (ms)

    // Generate random delay to mimic human interaction patterns
    function randomDelay() {
      return CHUNK_MIN_DELAY + Math.random() * (CHUNK_MAX_DELAY - CHUNK_MIN_DELAY);
    }

    // Generate low-entropy padding to balance high-entropy encrypted content
    function generateMetadata() {
      const actions = ['sync', 'update', 'save', 'upload', 'push', 'commit'];
      const sources = ['editor', 'browser', 'client', 'app', 'web', 'ui'];
      return {
        action: actions[Math.floor(Math.random() * actions.length)],
        source: sources[Math.floor(Math.random() * sources.length)],
        client_version: '1.0.0',
        platform: navigator.platform || 'web',
        locale: navigator.language || 'en-US',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${window.screen.width}x${window.screen.height}`,
        timestamp: new Date().toISOString(),
        user_agent_hash: btoa(navigator.userAgent.slice(0, 20)).slice(0, 12)
      };
    }

    // Generate unique identifiers that look like standard API fields
    function generateRequestId() {
      return 'req_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    }

    function generateClientId() {
      let clientId = sessionStorage.getItem('livepaste_client_id');
      if (!clientId) {
        clientId = 'client_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 10);
        sessionStorage.setItem('livepaste_client_id', clientId);
      }
      return clientId;
    }

    // Encrypt a batch of files and release plaintext immediately
    async function encryptBatch(batch) {
      const encrypted = await Promise.all(batch.map(async f => {
        const result = {
          path_hash: await hashPath(f.path),
          title: await encrypt(f.path),
          body: f.is_syncable ? await encrypt(f.content) : null,
          is_syncable: f.is_syncable,
          size_bytes: f.is_syncable ? null : f.size
        };
        // Release plaintext content immediately after encryption
        f.content = null;
        return result;
      }));
      return encrypted;
    }

    // Upload a single chunk to the server
    async function uploadChunk(sessionId, chunkIndex, files) {
      let chunkBody;
      if (USE_DISGUISED_API) {
        chunkBody = {
          workspace_id: roomId,
          session_token: sessionId,
          batch_index: chunkIndex,
          documents: files.map(f => ({
            id: f.path_hash,
            title: f.title,
            content: f.body,
            metadata: {
              refs: [f.path_hash],
              tracking: { utm_source: 'sync', utm_campaign: generateRequestId() }
            },
            is_syncable: f.is_syncable,
            size_bytes: f.size_bytes
          }))
        };
      } else {
        chunkBody = {
          session_id: sessionId,
          chunk_index: chunkIndex,
          files: files,
          client_timestamp: new Date().toISOString(),
          request_id: generateRequestId(),
          metadata: generateMetadata()
        };
      }

      const chunkRes = await apiFetch(API.syncChunk(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(chunkBody)
      });

      if (!chunkRes.ok) throw new Error(`Failed to upload chunk ${chunkIndex + 1}`);
      return chunkRes.json();
    }

    // Streaming sync: processes files as they're discovered, minimizing memory usage
    // Takes an async generator that yields file batches
    async function streamingSyncFiles(fileIterator, onProgress) {
      const clientId = generateClientId();

      // Start sync session (streaming mode - counts are estimates)
      let beginBody;
      if (USE_DISGUISED_API) {
        beginBody = {
          client_id: clientId,
          batch_count: -1,  // Unknown, streaming mode
          document_count: -1
        };
      } else {
        beginBody = {
          client_id: clientId,
          total_chunks: -1,  // Unknown, streaming mode
          total_files: -1,
          metadata: generateMetadata()
        };
      }

      const beginRes = await apiFetch(API.syncBegin(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(beginBody)
      });

      if (!beginRes.ok) throw new Error('Failed to begin sync');
      const beginData = await beginRes.json();
      const sessionId = USE_DISGUISED_API ? beginData.session_token : beginData.session_id;

      let chunkIndex = 0;
      let totalFiles = 0;
      let filesUploaded = 0;
      let currentChunk = [];
      let currentChunkSize = 0;

      // Process files as they come from the iterator
      for await (const fileBatch of fileIterator) {
        // Encrypt this batch immediately
        const encryptedBatch = await encryptBatch(fileBatch);

        for (const file of encryptedBatch) {
          const fileSize = JSON.stringify(file).length;

          // If adding this file would exceed chunk size, upload current chunk first
          if (currentChunkSize + fileSize > CHUNK_TARGET_SIZE && currentChunk.length > 0) {
            if (chunkIndex > 0) {
              await new Promise(r => setTimeout(r, randomDelay()));
            }
            await uploadChunk(sessionId, chunkIndex, currentChunk);
            filesUploaded += currentChunk.length;
            chunkIndex++;
            // Report progress after upload completes, not after encryption
            if (onProgress) onProgress({ chunksUploaded: chunkIndex, filesUploaded, filesProcessed: totalFiles });

            // Release chunk memory
            currentChunk = [];
            currentChunkSize = 0;
          }

          currentChunk.push(file);
          currentChunkSize += fileSize;
          totalFiles++;
        }
      }

      // Upload remaining files in the last chunk
      if (currentChunk.length > 0) {
        if (chunkIndex > 0) {
          await new Promise(r => setTimeout(r, randomDelay()));
        }
        await uploadChunk(sessionId, chunkIndex, currentChunk);
        filesUploaded += currentChunk.length;
        chunkIndex++;
        if (onProgress) onProgress({ chunksUploaded: chunkIndex, filesUploaded, filesProcessed: totalFiles });
      }

      // Small delay before completing
      await new Promise(r => setTimeout(r, randomDelay()));

      // Complete sync
      let completeBody;
      if (USE_DISGUISED_API) {
        completeBody = { session_token: sessionId };
      } else {
        completeBody = {
          session_id: sessionId,
          client_checksum: totalFiles.toString(),
          finalize: true,
          metadata: generateMetadata()
        };
      }

      const completeRes = await apiFetch(API.syncComplete(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(completeBody)
      });

      if (!completeRes.ok) throw new Error('Failed to complete sync');

      console.log(`Streaming sync complete: ${totalFiles} files in ${chunkIndex} chunks`);
      return completeRes.json();
    }

    // Legacy sync for small file lists (non-streaming)
    async function syncFiles(fileList) {
      // For small uploads, use simple batch approach
      async function* batchIterator() {
        const BATCH_SIZE = 30;
        for (let i = 0; i < fileList.length; i += BATCH_SIZE) {
          yield fileList.slice(i, i + BATCH_SIZE);
        }
      }

      return streamingSyncFiles(batchIterator(), ({ filesUploaded }) => {
        const progress = Math.round((filesUploaded / fileList.length) * 100);
        showToast(`Syncing... ${progress}%`);
      });
    }

    // Short polling - check version every 2 seconds
    let pollInterval = null;

    async function poll() {
      if (isPolling) return;
      
      // Skip polling if user is actively typing to prevent overwrites/jank
      if (Date.now() - lastActivityTime < POLLING_PAUSE_MS) return;

      isPolling = true;
      try {
        const res = await apiFetch(API.roomVersion());
        if (!res.ok) throw new Error('Version check failed');
        const versionData = await res.json();
        // Handle both disguised (revision) and original (version) responses
        const serverVersion = versionData.revision ?? versionData.version;

        if (serverVersion > version) {
          // Version changed, fetch ONLY updates (partial sync)
          const stateRes = await apiFetch(API.roomState(version));
          const state = await stateRes.json();
          await applyState(state);
        }
        setStatus(true);
      } catch (e) {
        if (e.message === 'Password required') {
          stopPolling();
        } else {
          console.error('Poll error:', e);
          setStatus(false);
        }
      } finally {
        isPolling = false;
      }
    }

    function stopPolling() {
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
    }

    function startPolling() {
      if (pollInterval) clearInterval(pollInterval);
      pollInterval = setInterval(poll, 2000);
    }

    async function applyState(state) {
      version = state.version;
      document.getElementById('versionBadge').textContent = version;
      
      if (state.op_seq !== undefined) {
        opSeq = state.op_seq;
      }

      // Decrypt new/updated files
      const newFiles = await Promise.all(state.files.map(async f => ({
        ...f,
        path: await decrypt(f.title),
        content: f.is_syncable ? await decrypt(f.body) : null
      })));

      // Merge into existing files
      for (const newFile of newFiles) {
        const existingIndex = files.findIndex(f => f.path_hash === newFile.path_hash);
        if (existingIndex !== -1) {
          // Update existing
          files[existingIndex] = newFile;
        } else {
          // Add new
          files.push(newFile);
        }
      }

      // Handle file deletions from delta sync
      if (state.deleted_path_hashes && state.deleted_path_hashes.length > 0) {
        const deletedSet = new Set(state.deleted_path_hashes);
        const deletedPaths = files.filter(f => deletedSet.has(f.path_hash)).map(f => f.path);
        files = files.filter(f => !deletedSet.has(f.path_hash));

        // If currently selected file was deleted, clear selection
        if (selectedFile && deletedSet.has(selectedFile.path_hash)) {
          console.log(`Selected file "${selectedFile.path}" was deleted by another client`);
          selectedFile = null;
          showEmptyState();
        }

        if (deletedPaths.length > 0) {
          console.log(`Delta sync: ${deletedPaths.length} file(s) deleted by other clients`);
        }
      }

      changesets = await Promise.all((state.changesets || []).map(async cs => ({
        ...cs,
        author: await decrypt(cs.author),
        message: await decrypt(cs.message),
        changes: await Promise.all((cs.changes || []).map(async ch => ({
          ...ch,
          file_path: await decrypt(ch.file_ref),
          old_content: ch.prev_body ? await decrypt(ch.prev_body) : '',
          new_content: await decrypt(ch.body),
          diff: ch.diff ? await decrypt(ch.diff) : ''
        })))
      })));
      renderFileTree();
      updateChangesetBanner();
      if (selectedFile) {
        const updatedFile = files.find(f => f.path === selectedFile.path);
        if (updatedFile && updatedFile.version !== selectedFile.version) {
          // Content changed on server
          if (updatedFile.is_syncable) {
             // Only update editor if we aren't typing (handled by poll check, but double check)
             // Or if using Ops, this might be handled by applyRemoteOp
             // For now, simple replace if changed
             const cursor = cmEditor ? cmEditor.getCursor() : null;
             const scroll = cmEditor ? cmEditor.getScrollInfo() : null;
             
             selectFile(updatedFile); // Re-select to update editor
             
             if (cmEditor && cursor) {
               cmEditor.setCursor(cursor);
               cmEditor.scrollTo(scroll.left, scroll.top);
             }
          }
        }
      }
    }

    let fileSearchQuery = '';
    const collapsedFolders = new Set();

    function filterFiles() {
      fileSearchQuery = document.getElementById('fileSearch').value.toLowerCase();
      renderFileTree();
    }

    function toggleFolder(path) {
      if (collapsedFolders.has(path)) {
        collapsedFolders.delete(path);
      } else {
        collapsedFolders.add(path);
      }
      renderFileTree();
    }

    function getAllFolderPaths() {
      const folders = new Set();
      for (const file of files) {
        const parts = file.path.split('/');
        let path = '';
        for (let i = 0; i < parts.length - 1; i++) {
          path = path ? path + '/' + parts[i] : parts[i];
          folders.add(path);
        }
      }
      return folders;
    }

    function expandAll() {
      collapsedFolders.clear();
      renderFileTree();
    }

    function collapseAll() {
      const allFolders = getAllFolderPaths();
      for (const folder of allFolders) {
        collapsedFolders.add(folder);
      }
      renderFileTree();
    }

    function renderFileTree() {
      const query = fileSearchQuery;
      const filteredFiles = query
        ? files.filter(f => f.path.toLowerCase().includes(query))
        : files;

      const tree = {};
      for (const file of filteredFiles) {
        const parts = file.path.split('/');
        let current = tree;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) current[parts[i]] = { _isDir: true };
          current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = file;
      }
      function renderNode(node, name, path) {
        path = path || '';
        const fullPath = path ? path + '/' + name : name;
        if (node._isDir) {
          const children = Object.entries(node).filter(e => e[0] !== '_isDir');
          // Auto-expand if only contains one subfolder and no files
          const hasOnlyOneSubfolder = children.length === 1 && children[0][1]._isDir;
          const isCollapsed = collapsedFolders.has(fullPath) && !hasOnlyOneSubfolder;
          const icon = isCollapsed ? '&#128193;' : '&#128194;';
          return `<div class="tree-item folder" onclick="toggleFolder('${fullPath}')"><span class="icon">${icon}</span><span class="name">${name}</span></div><div class="tree-children ${isCollapsed ? 'hidden' : ''}">${children.map(e => renderNode(e[1], e[0], fullPath)).join('')}</div>`;
        }
        const file = node;
        const isSelected = selectedFile && selectedFile.id === file.id;
        const hasPendingChange = changesets.some(cs => cs.changes.some(ch => ch.file_path === file.path && ch.status === 'pending'));
        return `<div class="tree-item ${isSelected ? 'selected' : ''} ${!file.is_syncable ? 'non-syncable' : ''}" onclick="selectFileById('${file.id}')"><span class="icon">${file.is_syncable ? '&#128196;' : '&#9675;'}</span><span class="name">${name}${hasPendingChange ? ' [!]' : ''}</span>${!file.is_syncable && file.size_bytes ? `<span class="size">${formatSize(file.size_bytes)}</span>` : ''}</div>`;
      }
      const rootEntries = Object.entries(tree);
      const fileTreeEl = document.getElementById('fileTree');
      const scrollTop = fileTreeEl.scrollTop; // Preserve scroll position
      fileTreeEl.innerHTML = rootEntries.length
        ? rootEntries.map(e => renderNode(e[1], e[0])).join('')
        : `<div style="padding:1rem;color:var(--muted);text-align:center">${query ? 'No matches' : 'No files yet'}</div>`;
      fileTreeEl.scrollTop = scrollTop; // Restore scroll position
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function selectFileById(id) {
      const file = files.find(f => f.id === id);
      if (file) selectFile(file);
    }

    function selectFile(file) {
      // Flush pending ops for previous file before switching
      if (pendingOps.length > 0) {
        sendPendingOps();
      }
      stopOpPolling();

      selectedFile = file;
      renderFileTree();
      document.getElementById('fileHeader').textContent = file.path;
      document.getElementById('emptyState').classList.add('hidden');
      const pendingChange = changesets.flatMap(cs => cs.changes).find(
        ch => ch.file_path === file.path && ch.status === 'pending'
      );
      if (pendingChange) {
        showDiffView(pendingChange);
      } else if (file.is_syncable) {
        showEditor(file);
      } else {
        showNonSyncable(file);
      }
    }

    function showEditor(file) {
      document.getElementById('diffView').classList.add('hidden');
      const wrapper = document.getElementById('editorWrapper');
      wrapper.classList.remove('hidden');

      const mode = detectLanguage(file.path);
      const newContent = file.content || '';

      if (!cmEditor) {
        // Create CodeMirror instance
        cmEditor = CodeMirror(wrapper, {
          value: newContent,
          mode: mode,
          theme: 'material-darker',
          lineNumbers: true,
          tabSize: 2,
          indentWithTabs: false,
          lineWrapping: true,
          matchBrackets: true,
          autoCloseBrackets: true
        });
        cmEditor.on('change', handleEditorChange);
        // Capture operations for delta sync (Zscaler stealth)
        cmEditor.on('change', captureLocalOp);
      } else {
        // Only update if content actually changed (preserve scroll/cursor otherwise)
        const currentContent = cmEditor.getValue();
        if (currentContent !== newContent) {
          isApplyingRemoteOps = true; // Prevent capturing this as a local op
          const scrollInfo = cmEditor.getScrollInfo();
          const cursor = cmEditor.getCursor();
          cmEditor.setValue(newContent);
          cmEditor.scrollTo(scrollInfo.left, scrollInfo.top);
          cmEditor.setCursor(cursor);
          isApplyingRemoteOps = false;
        }
        cmEditor.setOption('mode', mode);
      }
      cmEditor.refresh();

      // Start polling for ops on this file
      if (file.is_syncable) {
        startOpPolling();
      }
    }

    function showDiffView(change) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      const diff = change.diff || Diff.createPatch(change.file_path, change.old_content, change.new_content);
      const lines = diff.split('\n').map(line => {
        let cls = '';
        if (line.charAt(0) === '+' && line.substring(0,3) !== '+++') cls = 'added';
        else if (line.charAt(0) === '-' && line.substring(0,3) !== '---') cls = 'removed';
        else if (line.substring(0,2) === '@@') cls = 'header';
        return `<div class="diff-line ${cls}">${escapeHtml(line)}</div>`;
      }).join('');
      document.getElementById('diffView').innerHTML = `<div class="change-card"><div class="change-card-header"><span class="path">${change.file_path}</span><div class="change-card-actions"><button class="btn" onclick="acceptChange('${change.id}')">&check; Accept</button><button class="btn btn-secondary" onclick="rejectChange('${change.id}')">&times; Reject</button></div></div>${lines}</div>`;
    }

    function showNonSyncable(file) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      document.getElementById('diffView').innerHTML = `<div style="padding:2rem;text-align:center;color:var(--muted)"><p>&#9675; This file is only available on the source machine.</p><p style="margin-top:0.5rem">Size: ${formatSize(file.size_bytes || 0)}</p></div>`;
    }

    function showEmptyState() {
      document.getElementById('fileHeader').textContent = 'No file selected';
      document.getElementById('emptyState').classList.remove('hidden');
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.add('hidden');
    }

    function updateChangesetBanner() {
      const pending = changesets.filter(cs => cs.status === 'pending');
      const banner = document.getElementById('changesetBanner');
      if (pending.length > 0) {
        const cs = pending[0];
        const changeCount = cs.changes.filter(ch => ch.status === 'pending').length;
        document.getElementById('changesetMessage').textContent = `${cs.author || 'Someone'} proposed ${changeCount} change(s): "${cs.message || 'No message'}"`;
        banner.classList.remove('hidden');
      } else {
        banner.classList.add('hidden');
      }
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function setStatus(online) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      if (online) {
        dot.classList.remove('offline');
        text.textContent = 'Online';
      } else {
        dot.classList.add('offline');
        text.textContent = 'Reconnecting...';
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function handleEditorChange() {
      if (!selectedFile || !selectedFile.is_syncable || !cmEditor) return;
      
      lastActivityTime = Date.now();
      
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
        const content = cmEditor.getValue();
        if (content !== selectedFile.content) {
          try {
            await saveFile(selectedFile.path, content);
            selectedFile.content = content;
            showToast('Saved');
          } catch (e) {
            showToast('Save failed', 'error');
          }
        }
      }, 500);
    }


    function copyCode() {
      if (selectedFile) {
        navigator.clipboard.writeText(selectedFile.content || '');
        showToast('Copied to clipboard');
      }
    }

    function copyRoomUrl() {
      navigator.clipboard.writeText(window.location.href);
      showToast('URL copied to clipboard');
    }

    // Toggle steganographic encoding mode
    function toggleStegoMode() {
      USE_STEGO_ENCODING = !USE_STEGO_ENCODING;
      const toggle = document.getElementById('stegoToggle');
      if (USE_STEGO_ENCODING) {
        toggle.style.background = '#22c55e';
        toggle.textContent = 'STEGO';
        toggle.title = 'Steganographic HTML encoding enabled - click to toggle';
        showToast('Stego mode enabled - encrypted content hidden in HTML');
      } else {
        toggle.style.background = '#64748b';
        toggle.textContent = 'BASE64';
        toggle.title = 'Standard base64 encoding - click to enable steganographic mode';
        showToast('Stego mode disabled - using standard base64');
      }
      // Persist preference
      localStorage.setItem('livepaste_stego_mode', USE_STEGO_ENCODING ? '1' : '0');
    }

    // Initialize stego mode from saved preference
    function initStegoMode() {
      const saved = localStorage.getItem('livepaste_stego_mode');
      if (saved === '0') {
        USE_STEGO_ENCODING = false;
        const toggle = document.getElementById('stegoToggle');
        toggle.style.background = '#64748b';
        toggle.textContent = 'BASE64';
        toggle.title = 'Standard base64 encoding - click to enable steganographic mode';
      }
    }

    let qrCodeInstance = null;
    function showQRCode() {
      const url = window.location.href;
      const container = document.getElementById('qrCode');
      container.innerHTML = '';
      qrCodeInstance = new QRCode(container, {
        text: url,
        width: 200,
        height: 200,
        colorDark: '#000000',
        colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      document.getElementById('qrUrlDisplay').textContent = url;
      document.getElementById('qrModal').classList.remove('hidden');
    }

    function hideQRCode() {
      document.getElementById('qrModal').classList.add('hidden');
    }

    async function downloadAll() {
      const zip = new JSZip();
      for (const file of files) {
        if (file.is_syncable && file.content) {
          zip.file(file.path, file.content);
        }
      }
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `livepaste-${roomId}.zip`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showAddFileModal() {
      document.getElementById('addFileModal').classList.remove('hidden');
      document.getElementById('newFilePath').focus();
    }

    function hideAddFileModal() {
      document.getElementById('addFileModal').classList.add('hidden');
      document.getElementById('newFilePath').value = '';
    }

    async function createNewFile() {
      const path = document.getElementById('newFilePath').value.trim();
      if (!path) return;
      try {
        await saveFile(path, '');
        hideAddFileModal();
        showToast('File created');
      } catch (e) {
        showToast('Failed to create file', 'error');
      }
    }

    function uploadFolder() {
      if ('showDirectoryPicker' in window) {
        uploadFolderNative();
      } else {
        document.getElementById('folderInput').click();
      }
    }

    async function uploadFolderNative() {
      try {
        dirHandle = await window.showDirectoryPicker();
        document.getElementById('saveToDiskBtn').style.display = 'block';

        // Try to read .gitignore first
        gitignorePatterns = [];
        try {
          const gitignoreHandle = await dirHandle.getFileHandle('.gitignore');
          const gitignoreFile = await gitignoreHandle.getFile();
          const gitignoreContent = await gitignoreFile.text();
          gitignorePatterns = parseGitignore(gitignoreContent);
          console.log(`Loaded ${gitignorePatterns.length} gitignore patterns`);
        } catch (e) {
          console.log('No .gitignore found, continuing without it');
        }

        // Streaming scan: yields batches of files as they're discovered
        // This prevents loading all file contents into memory at once
        const SCAN_BATCH_SIZE = 20; // Files per batch
        let skippedCount = 0;
        let totalFiles = 0;

        async function* streamingScan(handle, path = '') {
          let batch = [];

          async function* scanDir(dirHandle, dirPath) {
            for await (const entry of dirHandle.values()) {
              const entryPath = dirPath ? dirPath + '/' + entry.name : entry.name;
              try {
                if (entry.kind === 'directory') {
                  if (!NEVER_SYNC_DIRS.has(entry.name) && !isGitignored(entryPath + '/')) {
                    // Recursively yield from subdirectory
                    yield* scanDir(entry, entryPath);
                  } else {
                    skippedCount++;
                  }
                } else {
                  const syncable = isSyncable(entryPath, null);
                  if (syncable) {
                    const file = await entry.getFile();
                    const content = await file.text();
                    batch.push({ path: entryPath, content, is_syncable: true });
                    totalFiles++;

                    // Yield batch when full
                    if (batch.length >= SCAN_BATCH_SIZE) {
                      yield batch;
                      batch = []; // Release reference for GC
                    }
                  } else {
                    skippedCount++;
                  }
                }
              } catch (fileErr) {
                console.warn(`Skipping ${entryPath}: ${fileErr.message}`);
                skippedCount++;
              }
            }
          }

          // Yield all files from recursive scan
          yield* scanDir(handle, path);

          // Yield remaining files in last batch
          if (batch.length > 0) {
            yield batch;
          }
        }

        console.log('Starting streaming folder upload...');
        showToast('Scanning and uploading...');

        const syncResult = await streamingSyncFiles(
          streamingScan(dirHandle),
          ({ filesUploaded, chunksUploaded }) => {
            showToast(`Uploading... ${filesUploaded} files (${chunksUploaded} chunks)`);
          }
        );

        if (totalFiles === 0) {
          showToast('No syncable files found', 'error');
          return;
        }

        // Normalize response if using disguised API
        let normalizedState = syncResult;
        if (USE_DISGUISED_API && syncResult.documents) {
          normalizedState = {
            version: syncResult.version,
            op_seq: syncResult.op_seq,
            files: syncResult.documents.map(d => ({
              id: d.id,
              path_hash: d.metadata?.refs?.[0],
              title: d.title,
              body: d.content,
              is_syncable: d.is_syncable,
              size_bytes: d.size_bytes,
              version: parseInt(d.metadata?.tracking?.utm_source) || 1
            })),
            changesets: syncResult.proposals || []
          };
        }

        await applyState(normalizedState);
        console.log(`Streaming upload complete: ${totalFiles} files, ${skippedCount} skipped`);
        showToast(`Uploaded ${totalFiles} files (${skippedCount} skipped)`);
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Folder upload error:', e);
          showToast(`Upload failed: ${e.message}`, 'error');
        }
      }
    }

    async function handleFolderUpload(event) {
      const inputFiles = event.target.files;
      if (!inputFiles.length) return;

      // Streaming upload for fallback file input
      const BATCH_SIZE = 20;
      let totalFiles = 0;
      let skippedCount = 0;

      async function* streamingFileInput() {
        let batch = [];
        for (const file of inputFiles) {
          const path = file.webkitRelativePath || file.name;
          if (isInIgnoredDir(path)) {
            skippedCount++;
            continue;
          }
          const syncable = isSyncable(path, null);
          if (syncable) {
            const content = await file.text();
            batch.push({ path, content, is_syncable: true });
            totalFiles++;

            if (batch.length >= BATCH_SIZE) {
              yield batch;
              batch = [];
            }
          } else {
            skippedCount++;
          }
        }
        if (batch.length > 0) {
          yield batch;
        }
      }

      showToast('Uploading...');
      const newState = await streamingSyncFiles(
        streamingFileInput(),
        ({ filesUploaded }) => {
          showToast(`Uploading... ${filesUploaded} files`);
        }
      );
      await applyState(newState);
      showToast(`Uploaded ${totalFiles} files (${skippedCount} skipped)`);
      event.target.value = '';
    }

    async function saveToDisk() {
      if (!dirHandle) return;
      try {
        for (const file of files) {
          if (!file.is_syncable || !file.content) continue;
          const parts = file.path.split('/');
          let currentHandle = dirHandle;
          for (let i = 0; i < parts.length - 1; i++) {
            currentHandle = await currentHandle.getDirectoryHandle(parts[i], { create: true });
          }
          const fileHandle = await currentHandle.getFileHandle(parts[parts.length - 1], { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(file.content);
          await writable.close();
        }
        showToast('Saved to disk');
      } catch (e) {
        console.error('Save to disk error:', e);
        showToast('Save failed', 'error');
      }
    }

    async function acceptAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/accept`, { method: 'POST' });
        showToast('Changes accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/reject`, { method: 'POST' });
        showToast('Changes rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    async function acceptChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/accept`, { method: 'POST' });
        showToast('Change accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/reject`, { method: 'POST' });
        showToast('Change rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    // Sidebar resize functionality
    function initSidebarResize() {
      const sidebar = document.getElementById('sidebar');
      const resizer = document.getElementById('sidebarResize');
      let isResizing = false;

      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        resizer.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 150 && newWidth <= 600) {
          sidebar.style.width = newWidth + 'px';
        }
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizer.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        }
      });
    }

    // Password modal functions
    function showPasswordModal() {
      document.getElementById('passwordModal').classList.remove('hidden');
      document.getElementById('passwordInput').focus();
      document.getElementById('passwordError').style.display = 'none';
    }

    function hidePasswordModal() {
      document.getElementById('passwordModal').classList.add('hidden');
      document.getElementById('passwordInput').value = '';
    }

    async function submitPassword() {
      const passwordInput = document.getElementById('passwordInput').value;
      if (!passwordInput) return;

      try {
        const passwordHash = await hashPassword(passwordInput);
        const res = await fetch('/api/room/' + roomId + '/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hidePasswordModal();
          // Retry loading the room
          const state = await fetchRoomState();
          await applyState(state);
          startPolling();
          showToast('Access granted');
        } else {
          document.getElementById('passwordError').textContent = 'Incorrect password';
          document.getElementById('passwordError').style.display = 'block';
        }
      } catch (e) {
        document.getElementById('passwordError').textContent = 'Error verifying password';
        document.getElementById('passwordError').style.display = 'block';
      }
    }

    function showSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.remove('hidden');
      document.getElementById('setPasswordInput').focus();
      document.getElementById('setPasswordError').style.display = 'none';
    }

    function hideSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.add('hidden');
      document.getElementById('setPasswordInput').value = '';
      document.getElementById('setPasswordConfirm').value = '';
    }

    async function setRoomPassword() {
      const password = document.getElementById('setPasswordInput').value;
      const confirm = document.getElementById('setPasswordConfirm').value;
      const errorEl = document.getElementById('setPasswordError');

      if (password.length < 4) {
        errorEl.textContent = 'Password must be at least 4 characters';
        errorEl.style.display = 'block';
        return;
      }

      if (password !== confirm) {
        errorEl.textContent = 'Passwords do not match';
        errorEl.style.display = 'block';
        return;
      }

      try {
        const passwordHash = await hashPassword(password);
        const res = await fetch('/api/room/' + roomId + '/password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash, current_password: roomPassword })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hasPassword = true;
          updatePasswordUI();
          hideSetPasswordModal();
          showToast('Password set successfully');
        } else {
          const data = await res.json();
          errorEl.textContent = data.error || 'Failed to set password';
          errorEl.style.display = 'block';
        }
      } catch (e) {
        errorEl.textContent = 'Error setting password';
        errorEl.style.display = 'block';
      }
    }

    async function confirmKillRoom() {
      if (confirm('Are you sure you want to PERMANENTLY delete this room and all its files? This cannot be undone.')) {
        try {
          const res = await apiFetch('/api/room/' + roomId, { method: 'DELETE' });
          if (res.ok) {
            alert('Room deleted.');
            window.location.href = '/';
          } else {
            showToast('Failed to delete room', 'error');
          }
        } catch (e) {
          showToast('Error deleting room', 'error');
        }
      }
    }

    function updatePasswordUI() {
      const statusEl = document.getElementById('passwordStatus');
      const btnEl = document.getElementById('passwordBtn');
      if (hasPassword) {
        statusEl.style.display = 'inline';
        statusEl.title = 'Room is password protected';
        btnEl.title = 'Change room password';
      } else {
        statusEl.style.display = 'none';
        btnEl.title = 'Set room password';
      }
    }

    // Directory creation functions
    function showAddDirModal() {
      document.getElementById('addDirModal').classList.remove('hidden');
      document.getElementById('newDirPath').focus();
    }

    function hideAddDirModal() {
      document.getElementById('addDirModal').classList.add('hidden');
      document.getElementById('newDirPath').value = '';
    }

    async function createNewDir() {
      let path = document.getElementById('newDirPath').value.trim();
      if (!path) return;
      // Ensure path doesn't end with /
      if (path.endsWith('/')) path = path.slice(0, -1);
      // Create .gitkeep file in the directory
      const gitkeepPath = path + '/.gitkeep';
      try {
        await saveFile(gitkeepPath, '');
        hideAddDirModal();
        showToast('Directory created');
      } catch (e) {
        showToast('Failed to create directory', 'error');
      }
    }

    // Browser Isolation Detection (Passive + Comprehensive)
    // Passive checks run automatically on load (non-suspicious)
    // Comprehensive checks run on user request (click isolation badge)

    let isolationIndicators = [];
    let isolationConfidence = 'unknown';
    let hasRunComprehensive = false;

    // Passive checks - just read existing data, no active probing
    function detectBrowserIsolation() {
      const indicators = [];
      const weights = {};

      // Check 1: Frame ancestry (standard anti-clickjacking check)
      try {
        if (window.self !== window.top) {
          indicators.push('Running in iframe');
          weights['iframe'] = 1;
        }
      } catch (e) {
        indicators.push('Cross-origin frame detected');
        weights['cross_origin'] = 2;
      }

      // Check 2: User agent analysis for known RBI proxies
      const ua = navigator.userAgent.toLowerCase();
      const isolationUAPatterns = [
        'menlo', 'fireglass', 'symantec', 'zscaler', 'netskope',
        'proofpoint', 'forcepoint', 'ericom', 'citrix', 'cloudflare',
        'browserling', 'browserstack', 'authentic8', 'island'
      ];

      for (const pattern of isolationUAPatterns) {
        if (ua.includes(pattern)) {
          indicators.push('Isolation proxy UA: ' + pattern);
          weights['ua_' + pattern] = 3;
        }
      }

      // Check 3: Screen capture API availability (just check existence)
      try {
        if (!('mediaDevices' in navigator) || !('getDisplayMedia' in navigator.mediaDevices)) {
          indicators.push('Screen capture API missing');
          weights['screencapture'] = 1;
        }
      } catch (e) {
        indicators.push('MediaDevices restricted');
        weights['mediadevices'] = 1;
      }

      // Check 4: Look for injected isolation scripts/elements
      const scripts = document.querySelectorAll('script[src*="isolation"], script[src*="menlo"], script[src*="zscaler"], script[src*="netskope"]');
      if (scripts.length > 0) {
        indicators.push('Injected isolation scripts');
        weights['injected_scripts'] = 2;
      }

      // Check 5: Check for isolation-specific globals
      if (window.__isolation__ || window.__menlo__ || window.__zscaler__ || window.__netskope__) {
        indicators.push('Isolation global variables');
        weights['isolation_global'] = 3;
      }

      // Calculate results - require multiple indicators for passive detection
      const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
      const isIsolated = totalWeight >= 3;

      if (totalWeight >= 5) {
        isolationConfidence = 'high';
      } else if (totalWeight >= 4) {
        isolationConfidence = 'medium';
      } else if (totalWeight >= 3) {
        isolationConfidence = 'low';
      }

      isolationIndicators = indicators;

      if (isIsolated) {
        console.warn('Browser isolation detected (passive):', indicators);
        showIsolationWarning();
      }
    }

    // Comprehensive checks - active probing (only on user click)
    async function runComprehensiveIsolationCheck() {
      if (hasRunComprehensive) {
        // Already ran, just show details
        showIsolationDetails();
        return;
      }

      showToast('Running isolation analysis...', 'info');
      const indicators = [...isolationIndicators]; // Start with passive indicators
      const weights = {};

      // Copy weights from passive detection
      if (indicators.some(i => i.includes('Cross-origin'))) weights['cross_origin'] = 2;
      if (indicators.some(i => i.includes('iframe'))) weights['iframe'] = 1;
      indicators.filter(i => i.includes('Isolation proxy UA')).forEach(i => {
        weights['ua_' + i.split(': ')[1]] = 3;
      });

      // Test 1: Animation frame latency (most reliable for pixel streaming)
      try {
        const frameLatency = await measureFrameLatency();
        if (frameLatency > 40) {
          indicators.push('High frame latency: ' + frameLatency.toFixed(1) + 'ms');
          weights['frame_latency'] = frameLatency > 100 ? 3 : 2;
        }
      } catch (e) { /* ignore */ }

      // Test 2: RequestAnimationFrame jitter analysis
      try {
        const { variance, avgDelta } = await measureFrameTimingVariance();
        if (variance < 0.5 && avgDelta > 20) {
          indicators.push('Suspiciously consistent frame timing (variance: ' + variance.toFixed(2) + ')');
          weights['frame_variance'] = 2;
        } else if (avgDelta > 25) {
          indicators.push('High average frame delta: ' + avgDelta.toFixed(1) + 'ms');
          weights['frame_delta'] = 2;
        }
      } catch (e) { /* ignore */ }

      // Test 3: WebGL virtual GPU detection
      try {
        const gpuInfo = checkForVirtualGPU();
        if (gpuInfo.isVirtual) {
          indicators.push('Virtual GPU: ' + gpuInfo.renderer);
          weights['virtual_gpu'] = 3;
        }
      } catch (e) { /* ignore */ }

      // Test 4: Canvas fingerprint complexity
      try {
        const canvasComplexity = getCanvasFingerprint();
        if (canvasComplexity < 1000) {
          indicators.push('Low canvas complexity (possible compression)');
          weights['canvas'] = 2;
        }
      } catch (e) { /* ignore */ }

      // Test 5: Network RTT check
      try {
        const rtt = await measureNetworkRTT();
        if (rtt > 100) {
          indicators.push('High network RTT: ' + rtt.toFixed(0) + 'ms');
          weights['network_rtt'] = rtt > 200 ? 3 : 2;
        }
      } catch (e) { /* ignore */ }

      // Test 6: WebRTC restrictions
      try {
        const webrtcBlocked = await checkWebRTCRestricted();
        if (webrtcBlocked) {
          indicators.push('WebRTC restricted');
          weights['webrtc'] = 2;
        }
      } catch (e) {
        indicators.push('WebRTC blocked');
        weights['webrtc'] = 2;
      }

      // Test 7: Local storage restrictions
      try {
        localStorage.setItem('__isolation_test__', '1');
        localStorage.removeItem('__isolation_test__');
      } catch (e) {
        indicators.push('Local storage restricted');
        weights['localstorage'] = 2;
      }

      // Test 8: Clipboard API availability (check existence only, NOT read)
      try {
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
          indicators.push('Clipboard API unavailable');
          weights['clipboard'] = 1;
        }
      } catch (e) {
        indicators.push('Clipboard API restricted');
        weights['clipboard'] = 1;
      }

      // Calculate confidence
      const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
      const isIsolated = totalWeight >= 4;

      if (totalWeight >= 8) {
        isolationConfidence = 'high';
      } else if (totalWeight >= 6) {
        isolationConfidence = 'medium';
      } else if (totalWeight >= 4) {
        isolationConfidence = 'low';
      } else {
        isolationConfidence = 'unknown';
      }

      // Determine detection type
      let detectionType = 'none';
      if (isIsolated) {
        if (weights['frame_latency'] >= 2 || weights['frame_variance'] >= 2) {
          detectionType = 'pixel-streaming';
        } else if (weights['virtual_gpu'] >= 2) {
          detectionType = 'virtual-machine';
        } else {
          detectionType = 'rbi';
        }
      }

      isolationIndicators = indicators;
      hasRunComprehensive = true;

      if (isIsolated) {
        console.warn('Browser isolation detected (comprehensive):', indicators, 'Type:', detectionType);
        showIsolationWarning();
      }

      showIsolationDetails();
    }

    function showIsolationWarning() {
      const badge = document.getElementById('isolationWarning');
      badge.style.display = 'inline';
      const confidenceText = isolationConfidence !== 'unknown' ? ' (' + isolationConfidence + ' confidence)' : '';
      badge.title = 'Browser isolation detected' + confidenceText + ' - click for details';
    }

    function showIsolationDetails() {
      const details = isolationIndicators.length > 0
        ? isolationIndicators.join('\n ')
        : 'No isolation indicators detected';
      const prefix = hasRunComprehensive ? 'Comprehensive analysis:\n ' : 'Passive detection:\n ';
      alert(prefix + details + '\n\nConfidence: ' + isolationConfidence);
    }

    // Detection helper functions
    function measureFrameLatency() {
      return new Promise(resolve => {
        const start = performance.now();
        requestAnimationFrame(() => {
          resolve(performance.now() - start);
        });
      });
    }

    function measureFrameTimingVariance() {
      return new Promise(resolve => {
        const timings = [];
        let lastTime = performance.now();
        let frameCount = 0;

        function checkFrame(time) {
          const delta = time - lastTime;
          timings.push(delta);
          lastTime = time;
          frameCount++;

          if (frameCount < 30) {
            requestAnimationFrame(checkFrame);
          } else {
            const avg = timings.reduce((a, b) => a + b) / timings.length;
            const variance = timings.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / timings.length;
            resolve({ variance, avgDelta: avg });
          }
        }

        requestAnimationFrame(checkFrame);
      });
    }

    function checkForVirtualGPU() {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      if (!gl) return { isVirtual: false, renderer: 'unknown' };

      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      if (!debugInfo) return { isVirtual: false, renderer: 'unknown' };

      const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
      const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
      const combined = (vendor + ' ' + renderer).toLowerCase();

      const virtualGPUs = [
        'swiftshader', 'vmware', 'virtualbox', 'parallels',
        'nvidia grid', 'microsoft basic render driver', 'llvmpipe', 'virgl', 'qemu'
      ];

      const isVirtual = virtualGPUs.some(gpu => {
        const pattern = new RegExp('\\b' + gpu.replace(/\s+/g, '\\s+') + '\\b', 'i');
        return pattern.test(combined);
      });

      return { isVirtual, renderer: vendor + ' ' + renderer };
    }

    function getCanvasFingerprint() {
      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 50;
      const ctx = canvas.getContext('2d');

      if (!ctx) return 10000;

      ctx.fillStyle = 'rgb(255, 0, 0)';
      ctx.fillRect(0, 0, 100, 50);

      const gradient = ctx.createLinearGradient(0, 0, 200, 50);
      gradient.addColorStop(0, 'blue');
      gradient.addColorStop(1, 'green');
      ctx.fillStyle = gradient;
      ctx.fillRect(100, 0, 100, 50);

      ctx.font = '18px Arial';
      ctx.fillStyle = 'white';
      ctx.fillText('Test123', 10, 30);

      return canvas.toDataURL().length;
    }

    async function measureNetworkRTT() {
      const start = performance.now();
      try {
        await fetch(window.location.origin + '?t=' + Date.now(), {
          method: 'HEAD',
          cache: 'no-store',
          mode: 'same-origin'
        });
      } catch (e) {
        return 0;
      }
      return performance.now() - start;
    }

    async function checkWebRTCRestricted() {
      return new Promise(resolve => {
        try {
          const pc = new RTCPeerConnection({ iceServers: [] });
          pc.createDataChannel('');

          pc.createOffer()
            .then(offer => pc.setLocalDescription(offer))
            .then(() => {
              pc.close();
              resolve(false);
            })
            .catch(() => {
              pc.close();
              resolve(true);
            });

          setTimeout(() => {
            pc.close();
            resolve(false);
          }, 500);
        } catch (e) {
          resolve(true);
        }
      });
    }

    // Fake Sync Traffic (Background Noise)
    function startFakeSync() {
      setInterval(() => {
        if (Math.random() > 0.7) return; // Skip sometimes
        apiFetch('/api/workspace/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cursor: generateClientId(), type: 'keepalive' })
        }).catch(() => {}); // Ignore errors
      }, 25000 + Math.random() * 20000); // Random interval 25s-45s
    }

    async function init() {
      await initEncryption();
      initStegoMode(); // Initialize stego mode from saved preference
      detectBrowserIsolation();
      startFakeSync();
      try {
        const info = await checkRoomInfo();
        hasPassword = info.has_password;
        updatePasswordUI();
        if (hasPassword && !roomPassword) {
          return void showPasswordModal();
        }
      } catch (e) {
        console.error("Failed to check room info:", e);
      }
      try {
        const state = await fetchRoomState();
        hasPassword = state.has_password || false;
        updatePasswordUI();
        await applyState(state);
        initSidebarResize();
        startPolling();
      } catch (e) {
        if (e.message === "Password required") {
          showPasswordModal();
        } else {
          console.error("Init error:", e);
          showToast("Failed to load room", "error");
        }
      }
    }
    init().catch(console.error);
  </script>
</body>
</html>
