<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LivePaste - E2E Encrypted Code Sharing</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --panel: #16213e;
      --border: #0f3460;
      --accent: #e94560;
      --text: #eee;
      --muted: #94a3b8;
      --success: #22c55e;
      --warning: #f59e0b;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 1rem;
    }
    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .room-url {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      color: var(--muted);
      font-family: monospace;
      font-size: 0.875rem;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 400px;
    }
    .room-url:hover { background: var(--border); }
    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }
    .status-dot.offline { background: var(--accent); }
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .btn:hover { opacity: 0.9; }
    .btn-secondary { background: var(--border); }
    .toolbar {
      display: flex;
      align-items: center;
      padding: 0.5rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 0.75rem;
    }
    .toolbar select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
    }
    .version-badge {
      margin-left: auto;
      font-size: 0.75rem;
      color: var(--muted);
      background: var(--bg);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }
    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    .sidebar {
      width: 280px;
      min-width: 150px;
      max-width: 600px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .sidebar-resize {
      position: absolute;
      top: 0;
      right: 0;
      width: 4px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      z-index: 10;
    }
    .sidebar-resize:hover, .sidebar-resize.dragging {
      background: var(--accent);
    }
    .file-tree {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .tree-item {
      display: flex;
      align-items: center;
      padding: 0.375rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      gap: 0.5rem;
    }
    .tree-item:hover { background: var(--border); }
    .tree-item.selected { background: var(--accent); }
    .tree-item.folder { font-weight: 500; }
    .tree-item.non-syncable { color: var(--muted); opacity: 0.7; }
    .tree-item .icon { width: 16px; text-align: center; }
    .tree-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .tree-item .size { font-size: 0.75rem; color: var(--muted); }
    .tree-children { padding-left: 1rem; }
    .sidebar-actions {
      padding: 0.75rem;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .sidebar-actions button { width: 100%; justify-content: center; }
    .editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .file-header {
      padding: 0.75rem 1rem;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      font-family: monospace;
      font-size: 0.875rem;
      color: var(--muted);
    }
    .editor-container {
      flex: 1;
      overflow: auto;
      position: relative;
    }
    .editor {
      width: 100%;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      border: none;
      resize: none;
      padding: 1rem;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
      tab-size: 2;
      outline: none;
    }
    .CodeMirror {
      height: 100% !important;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .editor-container .CodeMirror {
      background: var(--bg);
    }
    .code-view {
      padding: 1rem;
      margin: 0;
      overflow: auto;
      height: 100%;
    }
    .code-view code {
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      gap: 1rem;
    }
    .empty-state h2 { font-size: 1.5rem; color: var(--text); }
    .empty-state p { max-width: 400px; text-align: center; line-height: 1.5; }
    .changeset-banner {
      background: var(--warning);
      color: #000;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .changeset-banner .message { flex: 1; font-weight: 500; }
    .changeset-banner .btn { background: #000; color: var(--warning); }
    .diff-view {
      padding: 1rem;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow: auto;
    }
    .diff-line { padding: 0 0.5rem; }
    .diff-line.added { background: rgba(34, 197, 94, 0.2); color: var(--success); }
    .diff-line.removed { background: rgba(233, 69, 96, 0.2); color: var(--accent); }
    .diff-line.header { color: var(--muted); }
    .change-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      margin: 1rem;
      overflow: hidden;
    }
    .change-card-header {
      background: var(--panel);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      border-bottom: 1px solid var(--border);
    }
    .change-card-header .path { flex: 1; font-family: monospace; font-size: 0.875rem; }
    .change-card-actions { display: flex; gap: 0.5rem; }
    .change-card-actions .btn { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
    }
    .modal h3 { margin-bottom: 1rem; }
    .modal input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    .modal-actions { display: flex; gap: 0.75rem; justify-content: flex-end; }
    .hidden { display: none !important; }
    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      z-index: 200;
      animation: slideIn 0.2s ease;
    }
    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--accent); }
    @keyframes slideIn {
      from { transform: translateY(1rem); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo"><span>&#128274;</span><span>LivePaste</span></div>
    <div class="room-url" id="roomUrl" onclick="copyRoomUrl()"></div>
    <button class="btn" onclick="copyRoomUrl()">Share</button>
    <button class="btn btn-secondary" onclick="showQRCode()" title="QR code (for browser isolation)">QR</button>
    <button class="btn btn-secondary" id="passwordBtn" onclick="showSetPasswordModal()" title="Set room password">&#128272;</button>
    <button class="btn btn-danger" onclick="confirmKillRoom()" title="Delete Room" style="background:#e94560;color:white;border:none">&#128163;</button>
    <div class="status">
      <span id="isolationWarning" style="display:none;background:#e94560;color:white;padding:2px 6px;border-radius:4px;font-size:0.75rem;cursor:help" title="Browser isolation detected - your organization may be able to see decrypted content">ISOLATED</span>
      <span id="passwordStatus" style="display:none">&#128274;</span>
      <span>&#128274; E2E</span>
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Online</span>
    </div>
  </header>

  <div class="toolbar">
    <input type="text" id="fileSearch" placeholder="Search files..." oninput="filterFiles()" style="background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:0.375rem 0.5rem;color:var(--text);font-size:0.875rem;width:200px;">
    <button class="btn btn-secondary" onclick="copyCode()">Copy</button>
    <button class="btn btn-secondary" onclick="downloadAll()">Download All</button>
    <div class="version-badge">v<span id="versionBadge">0</span></div>
  </div>

  <div id="changesetBanner" class="changeset-banner hidden">
    <span class="message" id="changesetMessage"></span>
    <button class="btn" onclick="acceptAllChanges()">&#10003; Accept All</button>
    <button class="btn btn-secondary" onclick="rejectAllChanges()">&#10007; Reject All</button>
  </div>

  <main>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-resize" id="sidebarResize"></div>
      <div style="display:flex;gap:0.5rem;padding:0.5rem;border-bottom:1px solid var(--border)">
        <button class="btn btn-secondary" onclick="expandAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Expand All">&#9660; Expand</button>
        <button class="btn btn-secondary" onclick="collapseAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Collapse All">&#9654; Collapse</button>
      </div>
      <div class="file-tree" id="fileTree"></div>
      <div class="sidebar-actions">
        <button class="btn btn-secondary" onclick="showAddFileModal()">+ Add File</button>
        <button class="btn btn-secondary" onclick="showAddDirModal()">+ Add Directory</button>
        <button class="btn btn-secondary" onclick="uploadFolder()">&#128193; Upload Folder</button>
        <button class="btn btn-secondary" id="saveToDiskBtn" onclick="saveToDisk()" style="display:none">&#128190; Save to Disk</button>
        <input type="file" id="folderInput" webkitdirectory multiple style="display:none" onchange="handleFolderUpload(event)">
      </div>
    </aside>

    <section class="editor-panel">
      <div class="file-header" id="fileHeader">No file selected</div>
      <div class="editor-container" id="editorContainer">
        <div class="empty-state" id="emptyState">
          <h2>&#128274; LivePaste</h2>
          <p>E2E encrypted real-time code sharing. Upload a folder or create a file to get started.</p>
        </div>
        <div id="editorWrapper" class="hidden" style="height:100%"></div>
        <div class="diff-view hidden" id="diffView"></div>
      </div>
    </section>
  </main>

  <div id="addFileModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddFileModal()">
    <div class="modal">
      <h3>Add New File</h3>
      <input type="text" id="newFilePath" placeholder="path/to/file.js" onkeydown="if(event.key==='Enter')createNewFile()">
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddFileModal()">Cancel</button>
        <button class="btn" onclick="createNewFile()">Create</button>
      </div>
    </div>
  </div>

  <div id="addDirModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddDirModal()">
    <div class="modal">
      <h3>Add New Directory</h3>
      <input type="text" id="newDirPath" placeholder="path/to/directory" onkeydown="if(event.key==='Enter')createNewDir()">
      <p style="font-size:0.75rem;color:var(--muted);margin-top:0.5rem">Creates an empty .gitkeep file in the directory</p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddDirModal()">Cancel</button>
        <button class="btn" onclick="createNewDir()">Create</button>
      </div>
    </div>
  </div>

  <div id="passwordModal" class="modal-overlay hidden">
    <div class="modal">
      <h3 id="passwordModalTitle">Enter Room Password</h3>
      <input type="password" id="passwordInput" placeholder="Password" onkeydown="if(event.key==='Enter')submitPassword()">
      <p id="passwordError" style="color:var(--accent);font-size:0.875rem;margin-bottom:1rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn" onclick="submitPassword()">Enter</button>
      </div>
    </div>
  </div>

  <div id="setPasswordModal" class="modal-overlay hidden" onclick="if(event.target===this)hideSetPasswordModal()">
    <div class="modal">
      <h3>Set Room Password</h3>
      <p style="font-size:0.875rem;color:var(--muted);margin-bottom:1rem">Protect this room with a password. Others will need it to access.</p>
      <input type="password" id="setPasswordInput" placeholder="New password (min 4 chars)" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <input type="password" id="setPasswordConfirm" placeholder="Confirm password" style="margin-top:0.5rem" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <p id="setPasswordError" style="color:var(--accent);font-size:0.875rem;margin-top:0.5rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideSetPasswordModal()">Cancel</button>
        <button class="btn" onclick="setRoomPassword()">Set Password</button>
      </div>
    </div>
  </div>

  <div id="qrModal" class="modal-overlay hidden" onclick="if(event.target===this)hideQRCode()">
    <div class="modal" style="text-align:center;max-width:360px">
      <h3>Scan to Share</h3>
      <p style="font-size:0.875rem;color:var(--muted);margin-bottom:1rem">Use this if copy/paste is blocked (browser isolation)</p>
      <div id="qrCode" style="background:white;padding:1rem;border-radius:8px;display:inline-block"></div>
      <p style="font-size:0.75rem;color:var(--muted);margin-top:1rem;word-break:break-all" id="qrUrlDisplay"></p>
      <div class="modal-actions" style="margin-top:1rem">
        <button class="btn btn-secondary" onclick="hideQRCode()">Close</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/go/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/rust/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/ruby/ruby.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/php/php.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/swift/swift.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script>
    const roomId = window.location.pathname.split('/').pop();
    let encryptionKey = null;
    let cryptoKey = null;
    let version = 0;
    let files = [];
    let changesets = [];
    let selectedFile = null;
    let dirHandle = null;
    let isPolling = false;
    let saveTimeout = null;
    let lastActivityTime = 0;
    const POLLING_PAUSE_MS = 2000; // Pause polling for 2s after typing
    let cmEditor = null; // CodeMirror instance
    let roomPassword = sessionStorage.getItem('room_password_' + roomId) || '';
    let hasPassword = false;

    // === Operation-based sync (tiny deltas for Zscaler stealth) ===
    let opSeq = 0;                    // Current operation sequence from server
    let pendingOps = [];              // Ops waiting to be sent
    let isApplyingRemoteOps = false;  // Flag to prevent echo
    let opSendTimeout = null;         // Debounce for batching local ops
    const OP_SEND_DELAY = 100;        // Batch ops within 100ms
    const OP_POLL_INTERVAL = 1000;    // Poll for ops every 1s (faster than full state poll)
    const SNAPSHOT_THRESHOLD = 50;    // Snapshot after 50 ops
    let opsSinceSnapshot = 0;         // Counter for snapshot trigger
    let opPollInterval = null;        // Operation polling interval

    // === API Disguise Layer ===
    // Routes masquerade as a document management app to avoid detection
    const USE_DISGUISED_API = true;   // Set to false for original API routes

    // BIP39-style wordlist for key encoding (looks like document section link)
    const BIP39_WORDS = [
      'abandon','ability','able','about','above','absent','absorb','abstract','absurd','abuse',
      'access','accident','account','accuse','achieve','acid','acoustic','acquire','across','act',
      'action','actor','actress','actual','adapt','add','addict','address','adjust','admit',
      'adult','advance','advice','aerobic','affair','afford','afraid','again','age','agent',
      'agree','ahead','aim','air','airport','aisle','alarm','album','alcohol','alert',
      'alien','all','alley','allow','almost','alone','alpha','already','also','alter',
      'always','amateur','amazing','among','amount','amused','analyst','anchor','ancient','anger',
      'angle','angry','animal','ankle','announce','annual','another','answer','antenna','antique',
      'anxiety','any','apart','apology','appear','apple','approve','april','arch','arctic',
      'area','arena','argue','arm','armed','armor','army','around','arrange','arrest',
      'arrive','arrow','art','artefact','artist','artwork','ask','aspect','assault','asset',
      'assist','assume','asthma','athlete','atom','attack','attend','attitude','attract','auction',
      'audit','august','aunt','author','auto','autumn','average','avocado','avoid','awake',
      'aware','away','awesome','awful','awkward','axis','baby','bachelor','bacon','badge',
      'bag','balance','balcony','ball','bamboo','banana','banner','bar','barely','bargain',
      'barrel','base','basic','basket','battle','beach','bean','beauty','become','beef',
      'before','begin','behave','behind','believe','below','belt','bench','benefit','best',
      'betray','better','between','beyond','bicycle','bid','bike','bind','biology','bird',
      'birth','bitter','black','blade','blame','blanket','blast','bleak','bless','blind',
      'blood','blossom','blouse','blue','blur','blush','board','boat','body','boil',
      'bomb','bone','bonus','book','boost','border','boring','borrow','boss','bottom',
      'bounce','box','boy','bracket','brain','brand','brass','brave','bread','breeze',
      'brick','bridge','brief','bright','bring','brisk','broccoli','broken','bronze','broom',
      'brother','brown','brush','bubble','buddy','budget','buffalo','build','bulb','bulk',
      'bullet','bundle','bunker','burden','burger','burst','bus','business','busy','butter'
    ];

    // Encode key bytes as BIP39-style word sequence
    function keyToWords(keyBase64) {
      const bytes = Uint8Array.from(atob(keyBase64.replace(/-/g, '+').replace(/_/g, '/') + '='), c => c.charCodeAt(0));
      const words = [];
      for (let i = 0; i < bytes.length; i += 2) {
        const idx = (bytes[i] << 3) | (bytes[i + 1] >> 5);
        words.push(BIP39_WORDS[idx % BIP39_WORDS.length]);
      }
      return words.slice(0, 8).join('-');
    }

    // Decode BIP39-style word sequence back to key
    function wordsToKey(wordString) {
      const words = wordString.split('-');
      const bytes = new Uint8Array(32);
      for (let i = 0; i < words.length && i < 16; i++) {
        const idx = BIP39_WORDS.indexOf(words[i].toLowerCase());
        if (idx === -1) return null;
        const byteIdx = i * 2;
        bytes[byteIdx] = (idx >> 3) & 0xFF;
        if (byteIdx + 1 < 32) bytes[byteIdx + 1] = ((idx & 0x07) << 5) | (bytes[byteIdx + 1] & 0x1F);
      }
      return btoa(String.fromCharCode(...bytes)).replace(/[+\/=]/g, c => c === '+' ? '-' : c === '/' ? '_' : '').slice(0, 43);
    }

    // API endpoint mapping for disguise mode
    const API = {
      roomState: (since = 0, limit = 1000, offset = 0) => {
        const params = `?since=${since}&limit=${limit}&offset=${offset}`;
        return USE_DISGUISED_API 
          ? `/api/workspace/${roomId}${params}` 
          : `/api/room/${roomId}${params}`;
      },
      roomInfo: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/info` : `/api/room/${roomId}/info`,
      roomVersion: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/status` : `/api/room/${roomId}/version`,
      syncBegin: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/session` : `/api/room/${roomId}/sync/begin`,
      syncChunk: () => USE_DISGUISED_API ? `/api/documents/batch` : `/api/room/${roomId}/sync/chunk`,
      syncComplete: () => USE_DISGUISED_API ? `/api/workspace/${roomId}/finalize` : `/api/room/${roomId}/sync/complete`,
      ops: () => USE_DISGUISED_API ? `/api/documents` : `/api/room/${roomId}/ops`,
      files: () => USE_DISGUISED_API ? `/api/documents/save` : `/api/room/${roomId}/files`,
      deleteRoom: () => `/api/room/${roomId}` // Keep original for admin actions
    };

    async function initEncryption() {
      const fragment = window.location.hash.slice(1);
      if (fragment && fragment.length >= 32) {
        encryptionKey = fragment;
      } else {
        const keyBytes = crypto.getRandomValues(new Uint8Array(32));
        encryptionKey = btoa(String.fromCharCode(...keyBytes)).replace(/[+\/=]/g, c =>
          c === '+' ? '-' : c === '/' ? '_' : ''
        ).slice(0, 43);
        window.location.hash = encryptionKey;
      }
      const keyData = Uint8Array.from(atob(encryptionKey.replace(/-/g, '+').replace(/_/g, '/') + '='), c => c.charCodeAt(0));
      cryptoKey = await crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt']);
      document.getElementById('roomUrl').textContent = window.location.href;
    }

    async function encrypt(plaintext) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(plaintext);
      const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, encoded);
      const combined = new Uint8Array(iv.length + ciphertext.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(ciphertext), iv.length);
      // Convert to base64 in chunks to avoid stack overflow
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < combined.length; i += chunkSize) {
        binary += String.fromCharCode(...combined.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }

    async function decrypt(base64) {
      if (!base64) return '';
      try {
        const data = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = data.slice(0, 12);
        const ciphertext = data.slice(12);
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext);
        return new TextDecoder().decode(plaintext);
      } catch (e) {
        console.error('Decryption failed:', e);
        return '[Decryption Error]';
      }
    }

    // Hash path for deterministic lookups (SHA-256)
    async function hashPath(path) {
      const encoded = new TextEncoder().encode(path);
      const hashBuffer = await crypto.subtle.digest('SHA-256', encoded);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // === Operation functions (tiny deltas instead of full content) ===

    // Convert CodeMirror position to character offset
    function posToOffset(doc, pos) {
      let offset = 0;
      for (let i = 0; i < pos.line; i++) {
        offset += doc.getLine(i).length + 1; // +1 for newline
      }
      offset += pos.ch;
      return offset;
    }

    // Convert character offset to CodeMirror position
    function offsetToPos(doc, offset) {
      let remaining = offset;
      for (let line = 0; line < doc.lineCount(); line++) {
        const lineLength = doc.getLine(line).length + 1;
        if (remaining < lineLength) {
          return { line, ch: remaining };
        }
        remaining -= lineLength;
      }
      // Past end of doc
      const lastLine = doc.lineCount() - 1;
      return { line: lastLine, ch: doc.getLine(lastLine).length };
    }

    // Capture local edit and queue as operation
    function captureLocalOp(cm, change) {
      if (isApplyingRemoteOps) return; // Don't capture ops we're applying
      if (!selectedFile || !selectedFile.is_syncable) return;

      const doc = cm.getDoc();
      const pos = posToOffset(doc, change.from);
      const removedText = change.removed.join('\n');
      const insertedText = change.text.join('\n');

      const op = {
        file_path: selectedFile.path,
        pos: pos,
        del: removedText.length,
        ins: insertedText
      };

      pendingOps.push(op);
      scheduleSendOps();
    }

    // Schedule sending pending ops (debounced)
    function scheduleSendOps() {
      clearTimeout(opSendTimeout);
      opSendTimeout = setTimeout(sendPendingOps, OP_SEND_DELAY);
    }

    // Send pending ops to server
    async function sendPendingOps() {
      if (pendingOps.length === 0) return;

      const opsToSend = pendingOps.splice(0, pendingOps.length);
      const clientId = generateClientId();

      for (const op of opsToSend) {
        try {
          const pathHash = await hashPath(op.file_path);
          const opData = { pos: op.pos, del: op.del, ins: op.ins };
          const opEncrypted = await encrypt(JSON.stringify(opData));

          let url, body;
          if (USE_DISGUISED_API) {
            // Disguised as document edit
            url = `/api/documents/${pathHash}/edits`;
            body = {
              workspace_id: roomId,
              edit_data: opEncrypted,
              author_id: clientId,
              base_revision: selectedFile.version || 0
            };
          } else {
            url = '/api/room/' + roomId + '/ops';
            body = {
              file_path_hash: pathHash,
              op_encrypted: opEncrypted,
              client_id: clientId,
              base_version: selectedFile.version || 0,
              metadata: generateMetadata()
            };
          }

          const res = await apiFetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });

          if (res.ok) {
            const result = await res.json();
            opSeq = Math.max(opSeq, USE_DISGUISED_API ? result.revision : result.seq);
            opsSinceSnapshot++;

            // Trigger snapshot if needed
            if (opsSinceSnapshot >= SNAPSHOT_THRESHOLD) {
              await snapshotFile(selectedFile);
              opsSinceSnapshot = 0;
            }
          }
        } catch (e) {
          console.error('Failed to send op:', e);
          // Re-queue failed ops
          pendingOps.unshift(op);
        }
      }
    }

    // Poll for operations from other clients
    async function pollOps() {
      if (!selectedFile || !selectedFile.is_syncable) return;

      try {
        const pathHash = await hashPath(selectedFile.path);
        let url;
        if (USE_DISGUISED_API) {
          url = `/api/documents/${pathHash}/edits?workspace=${roomId}&since=${opSeq}`;
        } else {
          url = '/api/room/' + roomId + '/ops?since=' + opSeq + '&file=' + pathHash;
        }

        const res = await apiFetch(url);

        if (res.ok) {
          const data = await res.json();
          const clientId = generateClientId();

          // Apply ops from other clients (handle both API formats)
          const ops = USE_DISGUISED_API ? data.edits : data.ops;
          for (const op of ops) {
            const opClientId = USE_DISGUISED_API ? op.author_id : op.client_id;
            if (opClientId === clientId) continue; // Skip own ops

            try {
              const opEncrypted = USE_DISGUISED_API ? op.data : op.op_encrypted;
              const opData = JSON.parse(await decrypt(opEncrypted));
              applyRemoteOp(opData);
            } catch (e) {
              console.error('Failed to apply op:', e);
            }
          }

          opSeq = USE_DISGUISED_API ? data.current_revision : data.current_seq;
        }
      } catch (e) {
        console.error('Op poll error:', e);
      }
    }

    // Apply a remote operation to the editor
    function applyRemoteOp(op) {
      if (!cmEditor) return;

      isApplyingRemoteOps = true;
      try {
        const doc = cmEditor.getDoc();
        const from = offsetToPos(doc, op.pos);
        const to = offsetToPos(doc, op.pos + op.del);

        // Preserve cursor position
        const cursor = cmEditor.getCursor();
        const scrollInfo = cmEditor.getScrollInfo();

        cmEditor.replaceRange(op.ins, from, to, 'remote');

        // Restore cursor if it was after the edit
        cmEditor.setCursor(cursor);
        cmEditor.scrollTo(scrollInfo.left, scrollInfo.top);

        // Update local file content
        if (selectedFile) {
          selectedFile.content = cmEditor.getValue();
        }
      } finally {
        isApplyingRemoteOps = false;
      }
    }

    // Snapshot a file (compact ops into content)
    async function snapshotFile(file) {
      if (!file || !file.is_syncable) return;

      try {
        const pathHash = await hashPath(file.path);
        const contentEncrypted = await encrypt(file.content);

        const res = await apiFetch('/api/room/' + roomId + '/files/' + pathHash + '/snapshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content_encrypted: contentEncrypted,
            through_seq: opSeq,
            metadata: generateMetadata()
          })
        });

        if (res.ok) {
          console.log('Snapshot created for', file.path);
        }
      } catch (e) {
        console.error('Snapshot failed:', e);
      }
    }

    // Start operation polling for a file
    function startOpPolling() {
      stopOpPolling();
      opPollInterval = setInterval(pollOps, OP_POLL_INTERVAL);
    }

    // Stop operation polling
    function stopOpPolling() {
      if (opPollInterval) {
        clearInterval(opPollInterval);
        opPollInterval = null;
      }
    }

    const SYNCABLE_EXT = new Set(['.js','.ts','.jsx','.tsx','.mjs','.cjs','.py','.java','.kt','.go','.rs','.rb','.php','.swift','.c','.cpp','.h','.cs','.lua','.sh','.bash','.json','.yaml','.yml','.toml','.xml','.html','.htm','.css','.scss','.sass','.md','.mdx','.txt','.sql','.vue','.svelte','.env','.gitignore','.dockerfile']);
    const NEVER_SYNC_EXT = new Set(['.jar','.exe','.dll','.so','.o','.a','.pyc','.wasm','.zip','.tar','.gz','.rar','.7z','.png','.jpg','.jpeg','.gif','.ico','.svg','.webp','.mp3','.mp4','.wav','.avi','.mov','.woff','.woff2','.ttf','.otf','.pdf','.doc','.docx','.xls','.xlsx','.ppt','.db','.sqlite','.pem','.key','.crt']);
    const NEVER_SYNC_DIRS = new Set(['node_modules','.git','dist','build','out','target','__pycache__','.next','vendor','venv','.venv','coverage','.idea','.vscode']);

    // Simple gitignore pattern matcher
    let gitignorePatterns = [];

    function parseGitignore(content) {
      const patterns = [];
      for (const line of content.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) continue;
        try {
          let pattern = trimmed;
          let isNegation = pattern.startsWith('!');
          if (isNegation) pattern = pattern.slice(1);
          let isDir = pattern.endsWith('/');
          if (isDir) pattern = pattern.slice(0, -1);
          // Escape regex special chars
          pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          // Convert glob patterns back
          pattern = pattern.replace(/\\\*\\\*/g, '.*');
          pattern = pattern.replace(/\\\*/g, '[^/]*');
          pattern = pattern.replace(/\\\?/g, '.');
          // Handle patterns starting with /
          if (pattern.startsWith('\\/')) {
            pattern = '^' + pattern.slice(2);
          } else {
            pattern = '(^|/)' + pattern;
          }
          if (isDir) pattern += '(/|$)';
          else pattern += '($|/)';
          patterns.push({ regex: new RegExp(pattern), isNegation, isDir });
        } catch (e) {
          console.warn('Invalid gitignore pattern:', trimmed, e);
        }
      }
      return patterns;
    }

    function isGitignored(path) {
      let ignored = false;
      for (const { regex, isNegation } of gitignorePatterns) {
        if (regex.test(path)) {
          ignored = !isNegation;
        }
      }
      return ignored;
    }

    function getExtension(filename) {
      const parts = filename.split('.');
      return parts.length > 1 ? '.' + parts.pop().toLowerCase() : '';
    }

    function isInIgnoredDir(path) {
      const parts = path.split('/');
      return parts.some(p => NEVER_SYNC_DIRS.has(p));
    }

    function isSyncable(path, content) {
      if (isInIgnoredDir(path)) return false;
      const filename = path.split('/').pop();
      if (filename === '.DS_Store' || filename === 'Thumbs.db') return false;
      if (isGitignored(path)) return false;
      const ext = getExtension(path);
      if (NEVER_SYNC_EXT.has(ext)) return false;
      if (SYNCABLE_EXT.has(ext)) return true;
      if (content && typeof content === 'string') {
        // Check for binary content by looking for control characters
        const sample = content.slice(0, 8000);
        let controlCount = 0;
        for (let i = 0; i < sample.length; i++) {
          const code = sample.charCodeAt(i);
          if ((code >= 0 && code <= 8) || code === 11 || code === 12 || (code >= 14 && code <= 31)) {
            controlCount++;
          }
        }
        if (controlCount / Math.min(content.length, 8000) > 0.1) return false;
      }
      return true;
    }

    function detectLanguage(filename) {
      const ext = getExtension(filename);
      // CodeMirror mode names
      const map = {
        '.js': 'javascript', '.mjs': 'javascript', '.cjs': 'javascript', '.jsx': 'javascript',
        '.ts': 'text/typescript', '.tsx': 'text/typescript',
        '.py': 'python',
        '.java': 'text/x-java', '.kt': 'text/x-kotlin',
        '.cs': 'text/x-csharp', '.cpp': 'text/x-c++src', '.c': 'text/x-csrc', '.h': 'text/x-c++hdr',
        '.go': 'go', '.rs': 'rust', '.rb': 'ruby', '.php': 'php',
        '.swift': 'swift', '.sql': 'sql',
        '.html': 'htmlmixed', '.htm': 'htmlmixed',
        '.css': 'css', '.scss': 'css',
        '.json': 'application/json',
        '.yaml': 'yaml', '.yml': 'yaml',
        '.md': 'markdown', '.sh': 'shell', '.bash': 'shell',
        '.xml': 'xml', '.svg': 'xml'
      };
      return map[ext] || 'text/plain';
    }

    // Hash password before sending (Client-side protection)
    async function hashPassword(password) {
      if (!password) return '';
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // API fetch with password header
    async function apiFetch(url, options = {}) {
      const headers = { ...options.headers };
      if (roomPassword) {
        headers['X-Room-Password'] = roomPassword;
      }
      const res = await fetch(url, { ...options, headers });
      if (res.status === 401) {
        const data = await res.json();
        if (data.password_required) {
          showPasswordModal();
          throw new Error('Password required');
        }
      }
      return res;
    }

    async function fetchRoomState() {
      let allFiles = [];
      let offset = 0;
      const LIMIT = 50; // Chunk size
      let hasMore = true;
      let initialData = null;

      while (hasMore) {
        // Fetch chunk
        const res = await apiFetch(API.roomState(0, LIMIT, offset));
        if (!res.ok) throw new Error('Failed to fetch room chunk');
        const data = await res.json();

        // Normalize if disguised
        let normalized;
        if (USE_DISGUISED_API) {
          normalized = {
            version: data.version,
            op_seq: data.op_seq,
            has_password: data.has_password,
            files: data.documents.map(d => ({
              id: d.id,
              path_hash: d.metadata?.refs?.[0],
              path_encrypted: d.title,
              content_encrypted: d.content,
              is_syncable: d.is_syncable,
              size_bytes: d.size_bytes,
              version: parseInt(d.metadata?.tracking?.utm_source) || 1
            })),
            changesets: data.proposals || [],
            has_more: data.has_more
          };
        } else {
          normalized = data;
        }

        if (offset === 0) initialData = normalized;
        allFiles.push(...normalized.files);
        
hasMore = normalized.has_more;
        offset += LIMIT;
        
        // Optional: could yield to UI here to show progress
        if (hasMore) {
           console.log(`Loaded ${allFiles.length} files...`);
           await new Promise(r => setTimeout(r, 50)); // Tiny delay to not block UI
        }
      }
      
      initialData.files = allFiles;
      return initialData;
    }

    async function checkRoomInfo() {
      const res = await fetch(API.roomInfo());
      if (!res.ok) throw new Error('Failed to get room info');
      const data = await res.json();
      // Normalize from disguised API
      if (USE_DISGUISED_API) {
        return { id: data.workspace_id, has_password: data.requires_auth };
      }
      return data;
    }

    async function saveFile(path, content, isSyncableFile) {
      if (isSyncableFile === undefined) isSyncableFile = true;
      const pathHash = await hashPath(path);
      const pathEnc = await encrypt(path);
      const contentEnc = isSyncableFile ? await encrypt(content) : null;

      let body;
      if (USE_DISGUISED_API) {
        // Disguised as document save
        body = {
          workspace_id: roomId,
          title: pathEnc,
          content: contentEnc,
          metadata: {
            refs: [pathHash],
            tracking: { utm_source: 'editor', utm_medium: 'direct' }
          },
          is_syncable: isSyncableFile,
          size_bytes: isSyncableFile ? null : content.length
        };
      } else {
        body = {
          path_hash: pathHash,
          path_encrypted: pathEnc,
          content_encrypted: contentEnc,
          is_syncable: isSyncableFile,
          size_bytes: isSyncableFile ? null : content.length
        };
      }

      const res = await apiFetch(API.files(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!res.ok) throw new Error('Failed to save file');
      return res.json();
    }

    async function deleteFile(fileId) {
      const res = await apiFetch('/api/room/' + roomId + '/files/' + fileId, { method: 'DELETE' });
      if (!res.ok) throw new Error('Failed to delete file');
    }

    // Stealth chunked sync - designed for enterprise proxy compatibility
    const CHUNK_TARGET_SIZE = 150 * 1024; // ~150KB per chunk (well under DLP thresholds)
    const CHUNK_MIN_DELAY = 200;  // Min delay between chunks (ms)
    const CHUNK_MAX_DELAY = 800;  // Max delay between chunks (ms)

    // Generate random delay to mimic human interaction patterns
    function randomDelay() {
      return CHUNK_MIN_DELAY + Math.random() * (CHUNK_MAX_DELAY - CHUNK_MIN_DELAY);
    }

    // Generate low-entropy padding to balance high-entropy encrypted content
    function generateMetadata() {
      const actions = ['sync', 'update', 'save', 'upload', 'push', 'commit'];
      const sources = ['editor', 'browser', 'client', 'app', 'web', 'ui'];
      return {
        action: actions[Math.floor(Math.random() * actions.length)],
        source: sources[Math.floor(Math.random() * sources.length)],
        client_version: '1.0.0',
        platform: navigator.platform || 'web',
        locale: navigator.language || 'en-US',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${window.screen.width}x${window.screen.height}`,
        timestamp: new Date().toISOString(),
        user_agent_hash: btoa(navigator.userAgent.slice(0, 20)).slice(0, 12)
      };
    }

    // Generate unique identifiers that look like standard API fields
    function generateRequestId() {
      return 'req_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    }

    function generateClientId() {
      let clientId = sessionStorage.getItem('livepaste_client_id');
      if (!clientId) {
        clientId = 'client_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 10);
        sessionStorage.setItem('livepaste_client_id', clientId);
      }
      return clientId;
    }

    async function syncFiles(fileList) {
      // Encrypt all files first (CPU-bound, do in batches)
      const ENCRYPT_BATCH_SIZE = 30;
      const encrypted = [];

      for (let i = 0; i < fileList.length; i += ENCRYPT_BATCH_SIZE) {
        const batch = fileList.slice(i, i + ENCRYPT_BATCH_SIZE);
        const batchEncrypted = await Promise.all(batch.map(async f => ({
          path_hash: await hashPath(f.path),
          path_encrypted: await encrypt(f.path),
          content_encrypted: f.is_syncable ? await encrypt(f.content) : null,
          is_syncable: f.is_syncable,
          size_bytes: f.is_syncable ? null : f.size
        })));
        encrypted.push(...batchEncrypted);
        console.log(`Encrypted ${Math.min(i + ENCRYPT_BATCH_SIZE, fileList.length)}/${fileList.length} files`);
      }

      // Calculate chunk sizes based on payload size, not file count
      const chunks = [];
      let currentChunk = [];
      let currentSize = 0;

      for (const file of encrypted) {
        const fileSize = JSON.stringify(file).length;
        if (currentSize + fileSize > CHUNK_TARGET_SIZE && currentChunk.length > 0) {
          chunks.push(currentChunk);
          currentChunk = [];
          currentSize = 0;
        }
        currentChunk.push(file);
        currentSize += fileSize;
      }
      if (currentChunk.length > 0) {
        chunks.push(currentChunk);
      }

      console.log(`Split into ${chunks.length} chunks for upload`);

      // Start sync session
      const clientId = generateClientId();
      let beginBody;
      if (USE_DISGUISED_API) {
        beginBody = {
          client_id: clientId,
          batch_count: chunks.length,
          document_count: encrypted.length
        };
      } else {
        beginBody = {
          client_id: clientId,
          total_chunks: chunks.length,
          total_files: encrypted.length,
          metadata: generateMetadata()
        };
      }

      const beginRes = await apiFetch(API.syncBegin(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(beginBody)
      });

      if (!beginRes.ok) throw new Error('Failed to begin sync');
      const beginData = await beginRes.json();
      const sessionId = USE_DISGUISED_API ? beginData.session_token : beginData.session_id;

      // Upload chunks with random delays
      for (let i = 0; i < chunks.length; i++) {
        if (i > 0) {
          // Random delay between chunks to mimic human behavior
          await new Promise(r => setTimeout(r, randomDelay()));
        }

        let chunkBody;
        if (USE_DISGUISED_API) {
          // Transform files to document format
          chunkBody = {
            workspace_id: roomId,
            session_token: sessionId,
            batch_index: i,
            documents: chunks[i].map(f => ({
              id: f.path_hash,
              title: f.path_encrypted,
              content: f.content_encrypted,
              metadata: {
                refs: [f.path_hash],
                tracking: { utm_source: 'sync', utm_campaign: generateRequestId() }
              },
              is_syncable: f.is_syncable,
              size_bytes: f.size_bytes
            }))
          };
        } else {
          chunkBody = {
            session_id: sessionId,
            chunk_index: i,
            files: chunks[i],
            client_timestamp: new Date().toISOString(),
            request_id: generateRequestId(),
            metadata: generateMetadata()
          };
        }

        const chunkRes = await apiFetch(API.syncChunk(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(chunkBody)
        });

        if (!chunkRes.ok) throw new Error(`Failed to upload chunk ${i + 1}/${chunks.length}`);

        const progress = Math.round(((i + 1) / chunks.length) * 100);
        console.log(`Uploaded chunk ${i + 1}/${chunks.length} (${progress}%)`);
        showToast(`Syncing... ${progress}%`);
      }

      // Small delay before completing
      await new Promise(r => setTimeout(r, randomDelay()));

      // Complete sync
      let completeBody;
      if (USE_DISGUISED_API) {
        completeBody = { session_token: sessionId };
      } else {
        completeBody = {
          session_id: sessionId,
          client_checksum: encrypted.length.toString(),
          finalize: true,
          metadata: generateMetadata()
        };
      }

      const completeRes = await apiFetch(API.syncComplete(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(completeBody)
      });

      if (!completeRes.ok) throw new Error('Failed to complete sync');
      return completeRes.json();
    }

    // Short polling - check version every 2 seconds
    let pollInterval = null;

    async function poll() {
      if (isPolling) return;
      
      // Skip polling if user is actively typing to prevent overwrites/jank
      if (Date.now() - lastActivityTime < POLLING_PAUSE_MS) return;

      isPolling = true;
      try {
        const res = await apiFetch(API.roomVersion());
        if (!res.ok) throw new Error('Version check failed');
        const versionData = await res.json();
        // Handle both disguised (revision) and original (version) responses
        const serverVersion = versionData.revision ?? versionData.version;

        if (serverVersion > version) {
          // Version changed, fetch ONLY updates (partial sync)
          const stateRes = await apiFetch(API.roomState(version));
          const state = await stateRes.json();
          await applyState(state);
        }
        setStatus(true);
      } catch (e) {
        if (e.message === 'Password required') {
          stopPolling();
        } else {
          console.error('Poll error:', e);
          setStatus(false);
        }
      } finally {
        isPolling = false;
      }
    }

    function stopPolling() {
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
    }

    function startPolling() {
      if (pollInterval) clearInterval(pollInterval);
      pollInterval = setInterval(poll, 2000);
    }

    async function applyState(state) {
      version = state.version;
      document.getElementById('versionBadge').textContent = version;
      
      if (state.op_seq !== undefined) {
        opSeq = state.op_seq;
      }

      // Decrypt new/updated files
      const newFiles = await Promise.all(state.files.map(async f => ({
        ...f,
        path: await decrypt(f.path_encrypted),
        content: f.is_syncable ? await decrypt(f.content_encrypted) : null
      })));

      // Merge into existing files
      for (const newFile of newFiles) {
        const existingIndex = files.findIndex(f => f.path_hash === newFile.path_hash);
        if (existingIndex !== -1) {
          // Update existing
          files[existingIndex] = newFile;
        } else {
          // Add new
          files.push(newFile);
        }
      }

      // Note: We don't handle file deletions in this partial sync because
      // getRoomState only returns *updated* files. To handle deletions correctly
      // with partial sync, the server would need to return tombstones or we'd
      // need a different sync mechanism. For now, deletions might require a refresh
      // or we can implement a "deleted_files" list in the response.
      // Given the constraints, this is a trade-off for bandwidth.

      changesets = await Promise.all((state.changesets || []).map(async cs => ({
        ...cs,
        author: await decrypt(cs.author_encrypted),
        message: await decrypt(cs.message_encrypted),
        changes: await Promise.all((cs.changes || []).map(async ch => ({
          ...ch,
          file_path: await decrypt(ch.file_path_encrypted),
          old_content: ch.old_content_encrypted ? await decrypt(ch.old_content_encrypted) : '',
          new_content: await decrypt(ch.new_content_encrypted),
          diff: ch.diff_encrypted ? await decrypt(ch.diff_encrypted) : ''
        })))
      })));
      renderFileTree();
      updateChangesetBanner();
      if (selectedFile) {
        const updatedFile = files.find(f => f.path === selectedFile.path);
        if (updatedFile && updatedFile.version !== selectedFile.version) {
          // Content changed on server
          if (updatedFile.is_syncable) {
             // Only update editor if we aren't typing (handled by poll check, but double check)
             // Or if using Ops, this might be handled by applyRemoteOp
             // For now, simple replace if changed
             const cursor = cmEditor ? cmEditor.getCursor() : null;
             const scroll = cmEditor ? cmEditor.getScrollInfo() : null;
             
             selectFile(updatedFile); // Re-select to update editor
             
             if (cmEditor && cursor) {
               cmEditor.setCursor(cursor);
               cmEditor.scrollTo(scroll.left, scroll.top);
             }
          }
        }
      }
    }

    let fileSearchQuery = '';
    const collapsedFolders = new Set();

    function filterFiles() {
      fileSearchQuery = document.getElementById('fileSearch').value.toLowerCase();
      renderFileTree();
    }

    function toggleFolder(path) {
      if (collapsedFolders.has(path)) {
        collapsedFolders.delete(path);
      } else {
        collapsedFolders.add(path);
      }
      renderFileTree();
    }

    function getAllFolderPaths() {
      const folders = new Set();
      for (const file of files) {
        const parts = file.path.split('/');
        let path = '';
        for (let i = 0; i < parts.length - 1; i++) {
          path = path ? path + '/' + parts[i] : parts[i];
          folders.add(path);
        }
      }
      return folders;
    }

    function expandAll() {
      collapsedFolders.clear();
      renderFileTree();
    }

    function collapseAll() {
      const allFolders = getAllFolderPaths();
      for (const folder of allFolders) {
        collapsedFolders.add(folder);
      }
      renderFileTree();
    }

    function renderFileTree() {
      const query = fileSearchQuery;
      const filteredFiles = query
        ? files.filter(f => f.path.toLowerCase().includes(query))
        : files;

      const tree = {};
      for (const file of filteredFiles) {
        const parts = file.path.split('/');
        let current = tree;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) current[parts[i]] = { _isDir: true };
          current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = file;
      }
      function renderNode(node, name, path) {
        path = path || '';
        const fullPath = path ? path + '/' + name : name;
        if (node._isDir) {
          const children = Object.entries(node).filter(e => e[0] !== '_isDir');
          // Auto-expand if only contains one subfolder and no files
          const hasOnlyOneSubfolder = children.length === 1 && children[0][1]._isDir;
          const isCollapsed = collapsedFolders.has(fullPath) && !hasOnlyOneSubfolder;
          const icon = isCollapsed ? '&#128193;' : '&#128194;';
          return `<div class="tree-item folder" onclick="toggleFolder('${fullPath}')"><span class="icon">${icon}</span><span class="name">${name}</span></div><div class="tree-children ${isCollapsed ? 'hidden' : ''}">${children.map(e => renderNode(e[1], e[0], fullPath)).join('')}</div>`;
        }
        const file = node;
        const isSelected = selectedFile && selectedFile.id === file.id;
        const hasPendingChange = changesets.some(cs => cs.changes.some(ch => ch.file_path === file.path && ch.status === 'pending'));
        return `<div class="tree-item ${isSelected ? 'selected' : ''} ${!file.is_syncable ? 'non-syncable' : ''}" onclick="selectFileById('${file.id}')"><span class="icon">${file.is_syncable ? '&#128196;' : '&#9675;'}</span><span class="name">${name}${hasPendingChange ? ' [!]' : ''}</span>${!file.is_syncable && file.size_bytes ? `<span class="size">${formatSize(file.size_bytes)}</span>` : ''}</div>`;
      }
      const rootEntries = Object.entries(tree);
      const fileTreeEl = document.getElementById('fileTree');
      const scrollTop = fileTreeEl.scrollTop; // Preserve scroll position
      fileTreeEl.innerHTML = rootEntries.length
        ? rootEntries.map(e => renderNode(e[1], e[0])).join('')
        : `<div style="padding:1rem;color:var(--muted);text-align:center">${query ? 'No matches' : 'No files yet'}</div>`;
      fileTreeEl.scrollTop = scrollTop; // Restore scroll position
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function selectFileById(id) {
      const file = files.find(f => f.id === id);
      if (file) selectFile(file);
    }

    function selectFile(file) {
      // Flush pending ops for previous file before switching
      if (pendingOps.length > 0) {
        sendPendingOps();
      }
      stopOpPolling();

      selectedFile = file;
      renderFileTree();
      document.getElementById('fileHeader').textContent = file.path;
      document.getElementById('emptyState').classList.add('hidden');
      const pendingChange = changesets.flatMap(cs => cs.changes).find(
        ch => ch.file_path === file.path && ch.status === 'pending'
      );
      if (pendingChange) {
        showDiffView(pendingChange);
      } else if (file.is_syncable) {
        showEditor(file);
      } else {
        showNonSyncable(file);
      }
    }

    function showEditor(file) {
      document.getElementById('diffView').classList.add('hidden');
      const wrapper = document.getElementById('editorWrapper');
      wrapper.classList.remove('hidden');

      const mode = detectLanguage(file.path);
      const newContent = file.content || '';

      if (!cmEditor) {
        // Create CodeMirror instance
        cmEditor = CodeMirror(wrapper, {
          value: newContent,
          mode: mode,
          theme: 'material-darker',
          lineNumbers: true,
          tabSize: 2,
          indentWithTabs: false,
          lineWrapping: true,
          matchBrackets: true,
          autoCloseBrackets: true
        });
        cmEditor.on('change', handleEditorChange);
        // Capture operations for delta sync (Zscaler stealth)
        cmEditor.on('change', captureLocalOp);
      } else {
        // Only update if content actually changed (preserve scroll/cursor otherwise)
        const currentContent = cmEditor.getValue();
        if (currentContent !== newContent) {
          isApplyingRemoteOps = true; // Prevent capturing this as a local op
          const scrollInfo = cmEditor.getScrollInfo();
          const cursor = cmEditor.getCursor();
          cmEditor.setValue(newContent);
          cmEditor.scrollTo(scrollInfo.left, scrollInfo.top);
          cmEditor.setCursor(cursor);
          isApplyingRemoteOps = false;
        }
        cmEditor.setOption('mode', mode);
      }
      cmEditor.refresh();

      // Start polling for ops on this file
      if (file.is_syncable) {
        startOpPolling();
      }
    }

    function showDiffView(change) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      const diff = change.diff || Diff.createPatch(change.file_path, change.old_content, change.new_content);
      const lines = diff.split('\n').map(line => {
        let cls = '';
        if (line.charAt(0) === '+' && line.substring(0,3) !== '+++') cls = 'added';
        else if (line.charAt(0) === '-' && line.substring(0,3) !== '---') cls = 'removed';
        else if (line.substring(0,2) === '@@') cls = 'header';
        return `<div class="diff-line ${cls}">${escapeHtml(line)}</div>`;
      }).join('');
      document.getElementById('diffView').innerHTML = `<div class="change-card"><div class="change-card-header"><span class="path">${change.file_path}</span><div class="change-card-actions"><button class="btn" onclick="acceptChange('${change.id}')">&check; Accept</button><button class="btn btn-secondary" onclick="rejectChange('${change.id}')">&times; Reject</button></div></div>${lines}</div>`;
    }

    function showNonSyncable(file) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      document.getElementById('diffView').innerHTML = `<div style="padding:2rem;text-align:center;color:var(--muted)"><p>&#9675; This file is only available on the source machine.</p><p style="margin-top:0.5rem">Size: ${formatSize(file.size_bytes || 0)}</p></div>`;
    }

    function showEmptyState() {
      document.getElementById('fileHeader').textContent = 'No file selected';
      document.getElementById('emptyState').classList.remove('hidden');
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.add('hidden');
    }

    function updateChangesetBanner() {
      const pending = changesets.filter(cs => cs.status === 'pending');
      const banner = document.getElementById('changesetBanner');
      if (pending.length > 0) {
        const cs = pending[0];
        const changeCount = cs.changes.filter(ch => ch.status === 'pending').length;
        document.getElementById('changesetMessage').textContent = `${cs.author || 'Someone'} proposed ${changeCount} change(s): "${cs.message || 'No message'}"`;
        banner.classList.remove('hidden');
      } else {
        banner.classList.add('hidden');
      }
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function setStatus(online) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      if (online) {
        dot.classList.remove('offline');
        text.textContent = 'Online';
      } else {
        dot.classList.add('offline');
        text.textContent = 'Reconnecting...';
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function handleEditorChange() {
      if (!selectedFile || !selectedFile.is_syncable || !cmEditor) return;
      
      lastActivityTime = Date.now();
      
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
        const content = cmEditor.getValue();
        if (content !== selectedFile.content) {
          try {
            await saveFile(selectedFile.path, content);
            selectedFile.content = content;
            showToast('Saved');
          } catch (e) {
            showToast('Save failed', 'error');
          }
        }
      }, 500);
    }


    function copyCode() {
      if (selectedFile) {
        navigator.clipboard.writeText(selectedFile.content || '');
        showToast('Copied to clipboard');
      }
    }

    function copyRoomUrl() {
      navigator.clipboard.writeText(window.location.href);
      showToast('URL copied to clipboard');
    }

    let qrCodeInstance = null;
    function showQRCode() {
      const url = window.location.href;
      const container = document.getElementById('qrCode');
      container.innerHTML = '';
      qrCodeInstance = new QRCode(container, {
        text: url,
        width: 200,
        height: 200,
        colorDark: '#000000',
        colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.M
      });
      document.getElementById('qrUrlDisplay').textContent = url;
      document.getElementById('qrModal').classList.remove('hidden');
    }

    function hideQRCode() {
      document.getElementById('qrModal').classList.add('hidden');
    }

    async function downloadAll() {
      const zip = new JSZip();
      for (const file of files) {
        if (file.is_syncable && file.content) {
          zip.file(file.path, file.content);
        }
      }
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `livepaste-${roomId}.zip`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showAddFileModal() {
      document.getElementById('addFileModal').classList.remove('hidden');
      document.getElementById('newFilePath').focus();
    }

    function hideAddFileModal() {
      document.getElementById('addFileModal').classList.add('hidden');
      document.getElementById('newFilePath').value = '';
    }

    async function createNewFile() {
      const path = document.getElementById('newFilePath').value.trim();
      if (!path) return;
      try {
        await saveFile(path, '');
        hideAddFileModal();
        showToast('File created');
      } catch (e) {
        showToast('Failed to create file', 'error');
      }
    }

    function uploadFolder() {
      if ('showDirectoryPicker' in window) {
        uploadFolderNative();
      } else {
        document.getElementById('folderInput').click();
      }
    }

    async function uploadFolderNative() {
      try {
        dirHandle = await window.showDirectoryPicker();
        document.getElementById('saveToDiskBtn').style.display = 'block';

        // Try to read .gitignore first
        gitignorePatterns = [];
        try {
          const gitignoreHandle = await dirHandle.getFileHandle('.gitignore');
          const gitignoreFile = await gitignoreHandle.getFile();
          const gitignoreContent = await gitignoreFile.text();
          gitignorePatterns = parseGitignore(gitignoreContent);
          console.log(`Loaded ${gitignorePatterns.length} gitignore patterns`);
        } catch (e) {
          console.log('No .gitignore found, continuing without it');
        }

        const fileList = [];
        let skippedCount = 0;
        async function readDir(handle, path = '') {
          for await (const entry of handle.values()) {
            const entryPath = path ? path + '/' + entry.name : entry.name;
            try {
              if (entry.kind === 'directory') {
                if (!NEVER_SYNC_DIRS.has(entry.name) && !isGitignored(entryPath + '/')) {
                  await readDir(entry, entryPath);
                } else {
                  skippedCount++;
                }
              } else {
                const syncable = isSyncable(entryPath, null);
                if (syncable) {
                  const file = await entry.getFile();
                  const content = await file.text();
                  fileList.push({ path: entryPath, content, is_syncable: true });
                } else {
                  skippedCount++;
                }
              }
            } catch (fileErr) {
              console.warn(`Skipping ${entryPath}: ${fileErr.message}`);
              skippedCount++;
            }
          }
        }
        console.log('Starting folder scan...');
        await readDir(dirHandle);
        console.log(`Scan complete: ${fileList.length} files to upload, ${skippedCount} skipped`);

        if (fileList.length === 0) {
          showToast('No syncable files found', 'error');
          return;
        }

        showToast(`Syncing ${fileList.length} files...`);
        const syncResult = await syncFiles(fileList);

        // Normalize response if using disguised API
        let normalizedState = syncResult;
        if (USE_DISGUISED_API && syncResult.documents) {
          normalizedState = {
            version: syncResult.version,
            op_seq: syncResult.op_seq,
            files: syncResult.documents.map(d => ({
              id: d.id,
              path_hash: d.metadata?.refs?.[0],
              path_encrypted: d.title,
              content_encrypted: d.content,
              is_syncable: d.is_syncable,
              size_bytes: d.size_bytes,
              version: parseInt(d.metadata?.tracking?.utm_source) || 1
            })),
            changesets: syncResult.proposals || []
          };
        }

        await applyState(normalizedState);
        showToast(`Uploaded ${fileList.length} files (${skippedCount} skipped)`);
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Folder upload error:', e);
          showToast(`Upload failed: ${e.message}`, 'error');
        }
      }
    }

    async function handleFolderUpload(event) {
      const inputFiles = event.target.files;
      if (!inputFiles.length) return;
      const fileList = [];
      for (const file of inputFiles) {
        const path = file.webkitRelativePath || file.name;
        if (isInIgnoredDir(path)) continue;
        const syncable = isSyncable(path, null);
        if (syncable) {
          const content = await file.text();
          fileList.push({ path, content, is_syncable: true });
        } else {
          fileList.push({ path, content: '', is_syncable: false, size: file.size });
        }
      }
      const newState = await syncFiles(fileList);
      await applyState(newState);
      showToast(`Uploaded ${fileList.length} files`);
      event.target.value = '';
    }

    async function saveToDisk() {
      if (!dirHandle) return;
      try {
        for (const file of files) {
          if (!file.is_syncable || !file.content) continue;
          const parts = file.path.split('/');
          let currentHandle = dirHandle;
          for (let i = 0; i < parts.length - 1; i++) {
            currentHandle = await currentHandle.getDirectoryHandle(parts[i], { create: true });
          }
          const fileHandle = await currentHandle.getFileHandle(parts[parts.length - 1], { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(file.content);
          await writable.close();
        }
        showToast('Saved to disk');
      } catch (e) {
        console.error('Save to disk error:', e);
        showToast('Save failed', 'error');
      }
    }

    async function acceptAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/accept`, { method: 'POST' });
        showToast('Changes accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/reject`, { method: 'POST' });
        showToast('Changes rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    async function acceptChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/accept`, { method: 'POST' });
        showToast('Change accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/reject`, { method: 'POST' });
        showToast('Change rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    // Sidebar resize functionality
    function initSidebarResize() {
      const sidebar = document.getElementById('sidebar');
      const resizer = document.getElementById('sidebarResize');
      let isResizing = false;

      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        resizer.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 150 && newWidth <= 600) {
          sidebar.style.width = newWidth + 'px';
        }
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizer.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        }
      });
    }

    // Password modal functions
    function showPasswordModal() {
      document.getElementById('passwordModal').classList.remove('hidden');
      document.getElementById('passwordInput').focus();
      document.getElementById('passwordError').style.display = 'none';
    }

    function hidePasswordModal() {
      document.getElementById('passwordModal').classList.add('hidden');
      document.getElementById('passwordInput').value = '';
    }

    async function submitPassword() {
      const passwordInput = document.getElementById('passwordInput').value;
      if (!passwordInput) return;

      try {
        const passwordHash = await hashPassword(passwordInput);
        const res = await fetch('/api/room/' + roomId + '/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hidePasswordModal();
          // Retry loading the room
          const state = await fetchRoomState();
          await applyState(state);
          startPolling();
          showToast('Access granted');
        } else {
          document.getElementById('passwordError').textContent = 'Incorrect password';
          document.getElementById('passwordError').style.display = 'block';
        }
      } catch (e) {
        document.getElementById('passwordError').textContent = 'Error verifying password';
        document.getElementById('passwordError').style.display = 'block';
      }
    }

    function showSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.remove('hidden');
      document.getElementById('setPasswordInput').focus();
      document.getElementById('setPasswordError').style.display = 'none';
    }

    function hideSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.add('hidden');
      document.getElementById('setPasswordInput').value = '';
      document.getElementById('setPasswordConfirm').value = '';
    }

    async function setRoomPassword() {
      const password = document.getElementById('setPasswordInput').value;
      const confirm = document.getElementById('setPasswordConfirm').value;
      const errorEl = document.getElementById('setPasswordError');

      if (password.length < 4) {
        errorEl.textContent = 'Password must be at least 4 characters';
        errorEl.style.display = 'block';
        return;
      }

      if (password !== confirm) {
        errorEl.textContent = 'Passwords do not match';
        errorEl.style.display = 'block';
        return;
      }

      try {
        const passwordHash = await hashPassword(password);
        const res = await fetch('/api/room/' + roomId + '/password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash, current_password: roomPassword })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hasPassword = true;
          updatePasswordUI();
          hideSetPasswordModal();
          showToast('Password set successfully');
        } else {
          const data = await res.json();
          errorEl.textContent = data.error || 'Failed to set password';
          errorEl.style.display = 'block';
        }
      } catch (e) {
        errorEl.textContent = 'Error setting password';
        errorEl.style.display = 'block';
      }
    }

    async function confirmKillRoom() {
      if (confirm('Are you sure you want to PERMANENTLY delete this room and all its files? This cannot be undone.')) {
        try {
          const res = await apiFetch('/api/room/' + roomId, { method: 'DELETE' });
          if (res.ok) {
            alert('Room deleted.');
            window.location.href = '/';
          } else {
            showToast('Failed to delete room', 'error');
          }
        } catch (e) {
          showToast('Error deleting room', 'error');
        }
      }
    }

    function updatePasswordUI() {
      const statusEl = document.getElementById('passwordStatus');
      const btnEl = document.getElementById('passwordBtn');
      if (hasPassword) {
        statusEl.style.display = 'inline';
        statusEl.title = 'Room is password protected';
        btnEl.title = 'Change room password';
      } else {
        statusEl.style.display = 'none';
        btnEl.title = 'Set room password';
      }
    }

    // Directory creation functions
    function showAddDirModal() {
      document.getElementById('addDirModal').classList.remove('hidden');
      document.getElementById('newDirPath').focus();
    }

    function hideAddDirModal() {
      document.getElementById('addDirModal').classList.add('hidden');
      document.getElementById('newDirPath').value = '';
    }

    async function createNewDir() {
      let path = document.getElementById('newDirPath').value.trim();
      if (!path) return;
      // Ensure path doesn't end with /
      if (path.endsWith('/')) path = path.slice(0, -1);
      // Create .gitkeep file in the directory
      const gitkeepPath = path + '/.gitkeep';
      try {
        await saveFile(gitkeepPath, '');
        hideAddDirModal();
        showToast('Directory created');
      } catch (e) {
        showToast('Failed to create directory', 'error');
      }
    }

    // Detect browser isolation (Zscaler Cloud Browser, Menlo, etc.)
    async function detectBrowserIsolation() {
      const signs = [];

      // Check 1: Clipboard API blocked
      try {
        await navigator.clipboard.readText();
      } catch (e) {
        if (e.name === 'NotAllowedError' || e.message.includes('denied')) {
          signs.push('clipboard_blocked');
        }
      }

      // Check 2: Known isolation user agents / injected elements
      const ua = navigator.userAgent.toLowerCase();
      const isolationHints = ['menlo', 'isolation', 'cloudflare-browser', 'zscaler', 'symantec-ws'];
      for (const hint of isolationHints) {
        if (ua.includes(hint)) signs.push('ua_' + hint);
      }

      // Check 3: Look for injected isolation scripts/elements
      const scripts = document.querySelectorAll('script[src*="isolation"], script[src*="menlo"], script[src*="zscaler"]');
      if (scripts.length > 0) signs.push('injected_scripts');

      // Check 4: Check for isolation-specific globals
      if (window.__isolation__ || window.__menlo__ || window.__zscaler__) {
        signs.push('isolation_global');
      }

      // Check 5: Input latency test (pixel streaming adds ~50-200ms)
      const latencyTest = await measureInputLatency();
      if (latencyTest > 100) signs.push('high_latency_' + Math.round(latencyTest) + 'ms');

      if (signs.length > 0) {
        console.warn('Browser isolation detected:', signs);
        document.getElementById('isolationWarning').style.display = 'inline';
        document.getElementById('isolationWarning').title =
          'Browser isolation detected (' + signs.join(', ') + ') - your organization may be able to see decrypted content';
      }
    }

    function measureInputLatency() {
      return new Promise(resolve => {
        const start = performance.now();
        const input = document.createElement('input');
        input.style.cssText = 'position:fixed;top:-100px;opacity:0';
        document.body.appendChild(input);
        input.focus();

        const handler = () => {
          const latency = performance.now() - start;
          input.remove();
          resolve(latency);
        };

        input.addEventListener('focus', handler, { once: true });

        // Fallback timeout
        setTimeout(() => {
          input.remove();
          resolve(0);
        }, 500);
      });
    }

    async function init() {
      await initEncryption();

      // Check for browser isolation
      detectBrowserIsolation();

      // Check if room has password
      try {
        const info = await checkRoomInfo();
        hasPassword = info.has_password;
        updatePasswordUI();

        if (hasPassword && !roomPassword) {
          // Need password - show modal
          showPasswordModal();
          return;
        }
      } catch (e) {
        console.error('Failed to check room info:', e);
      }

      try {
        const state = await fetchRoomState();
        hasPassword = state.has_password || false;
        updatePasswordUI();
        await applyState(state);
        initSidebarResize();
        startPolling();
      } catch (e) {
        if (e.message === 'Password required') {
          showPasswordModal();
        } else {
          console.error('Init error:', e);
          showToast('Failed to load room', 'error');
        }
      }
    }

    init().catch(console.error);
  </script>
</body>
</html>
