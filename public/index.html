<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LivePaste - E2E Encrypted Code Sharing</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --panel: #16213e;
      --border: #0f3460;
      --accent: #e94560;
      --text: #eee;
      --muted: #94a3b8;
      --success: #22c55e;
      --warning: #f59e0b;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    header {
      display: flex;
      align-items: center;
      padding: 0.75rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 1rem;
    }
    .logo {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .room-url {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      color: var(--muted);
      font-family: monospace;
      font-size: 0.875rem;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 400px;
    }
    .room-url:hover { background: var(--border); }
    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }
    .status-dot.offline { background: var(--accent); }
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .btn:hover { opacity: 0.9; }
    .btn-secondary { background: var(--border); }
    .toolbar {
      display: flex;
      align-items: center;
      padding: 0.5rem 1rem;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      gap: 0.75rem;
    }
    .toolbar select {
      background: var(--bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
    }
    .version-badge {
      margin-left: auto;
      font-size: 0.75rem;
      color: var(--muted);
      background: var(--bg);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
    }
    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    .sidebar {
      width: 280px;
      min-width: 150px;
      max-width: 600px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .sidebar-resize {
      position: absolute;
      top: 0;
      right: 0;
      width: 4px;
      height: 100%;
      cursor: ew-resize;
      background: transparent;
      z-index: 10;
    }
    .sidebar-resize:hover, .sidebar-resize.dragging {
      background: var(--accent);
    }
    .file-tree {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .tree-item {
      display: flex;
      align-items: center;
      padding: 0.375rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      gap: 0.5rem;
    }
    .tree-item:hover { background: var(--border); }
    .tree-item.selected { background: var(--accent); }
    .tree-item.folder { font-weight: 500; }
    .tree-item.non-syncable { color: var(--muted); opacity: 0.7; }
    .tree-item .icon { width: 16px; text-align: center; }
    .tree-item .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .tree-item .size { font-size: 0.75rem; color: var(--muted); }
    .tree-children { padding-left: 1rem; }
    .sidebar-actions {
      padding: 0.75rem;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .sidebar-actions button { width: 100%; justify-content: center; }
    .editor-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .file-header {
      padding: 0.75rem 1rem;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      font-family: monospace;
      font-size: 0.875rem;
      color: var(--muted);
    }
    .editor-container {
      flex: 1;
      overflow: auto;
      position: relative;
    }
    .editor {
      width: 100%;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      border: none;
      resize: none;
      padding: 1rem;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
      tab-size: 2;
      outline: none;
    }
    .CodeMirror {
      height: 100% !important;
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .editor-container .CodeMirror {
      background: var(--bg);
    }
    .code-view {
      padding: 1rem;
      margin: 0;
      overflow: auto;
      height: 100%;
    }
    .code-view code {
      font-family: "Fira Code", "Monaco", "Menlo", monospace;
      font-size: 14px;
      line-height: 1.6;
    }
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      gap: 1rem;
    }
    .empty-state h2 { font-size: 1.5rem; color: var(--text); }
    .empty-state p { max-width: 400px; text-align: center; line-height: 1.5; }
    .changeset-banner {
      background: var(--warning);
      color: #000;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .changeset-banner .message { flex: 1; font-weight: 500; }
    .changeset-banner .btn { background: #000; color: var(--warning); }
    .diff-view {
      padding: 1rem;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
      overflow: auto;
    }
    .diff-line { padding: 0 0.5rem; }
    .diff-line.added { background: rgba(34, 197, 94, 0.2); color: var(--success); }
    .diff-line.removed { background: rgba(233, 69, 96, 0.2); color: var(--accent); }
    .diff-line.header { color: var(--muted); }
    .change-card {
      border: 1px solid var(--border);
      border-radius: 8px;
      margin: 1rem;
      overflow: hidden;
    }
    .change-card-header {
      background: var(--panel);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      border-bottom: 1px solid var(--border);
    }
    .change-card-header .path { flex: 1; font-family: monospace; font-size: 0.875rem; }
    .change-card-actions { display: flex; gap: 0.5rem; }
    .change-card-actions .btn { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    .modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 500px;
      width: 90%;
    }
    .modal h3 { margin-bottom: 1rem; }
    .modal input {
      width: 100%;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.75rem;
      color: var(--text);
      font-size: 1rem;
      margin-bottom: 1rem;
    }
    .modal-actions { display: flex; gap: 0.75rem; justify-content: flex-end; }
    .hidden { display: none !important; }
    .toast {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      z-index: 200;
      animation: slideIn 0.2s ease;
    }
    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--accent); }
    @keyframes slideIn {
      from { transform: translateY(1rem); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <header>
    <div class="logo"><span>&#128274;</span><span>LivePaste</span></div>
    <div class="room-url" id="roomUrl" onclick="copyRoomUrl()"></div>
    <button class="btn" onclick="copyRoomUrl()">Share</button>
    <button class="btn btn-secondary" id="passwordBtn" onclick="showSetPasswordModal()" title="Set room password">&#128272;</button>
    <button class="btn btn-danger" onclick="confirmKillRoom()" title="Delete Room" style="background:#e94560;color:white;border:none">&#128163;</button>
    <div class="status">
      <span id="passwordStatus" style="display:none">&#128274;</span>
      <span>&#128274; E2E</span>
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Online</span>
    </div>
  </header>

  <div class="toolbar">
    <input type="text" id="fileSearch" placeholder="Search files..." oninput="filterFiles()" style="background:var(--bg);border:1px solid var(--border);border-radius:4px;padding:0.375rem 0.5rem;color:var(--text);font-size:0.875rem;width:200px;">
    <button class="btn btn-secondary" onclick="copyCode()">Copy</button>
    <button class="btn btn-secondary" onclick="downloadAll()">Download All</button>
    <div class="version-badge">v<span id="versionBadge">0</span></div>
  </div>

  <div id="changesetBanner" class="changeset-banner hidden">
    <span class="message" id="changesetMessage"></span>
    <button class="btn" onclick="acceptAllChanges()">&#10003; Accept All</button>
    <button class="btn btn-secondary" onclick="rejectAllChanges()">&#10007; Reject All</button>
  </div>

  <main>
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-resize" id="sidebarResize"></div>
      <div style="display:flex;gap:0.5rem;padding:0.5rem;border-bottom:1px solid var(--border)">
        <button class="btn btn-secondary" onclick="expandAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Expand All">&#9660; Expand</button>
        <button class="btn btn-secondary" onclick="collapseAll()" style="flex:1;padding:0.25rem;font-size:0.75rem" title="Collapse All">&#9654; Collapse</button>
      </div>
      <div class="file-tree" id="fileTree"></div>
      <div class="sidebar-actions">
        <button class="btn btn-secondary" onclick="showAddFileModal()">+ Add File</button>
        <button class="btn btn-secondary" onclick="showAddDirModal()">+ Add Directory</button>
        <button class="btn btn-secondary" onclick="uploadFolder()">&#128193; Upload Folder</button>
        <button class="btn btn-secondary" id="saveToDiskBtn" onclick="saveToDisk()" style="display:none">&#128190; Save to Disk</button>
        <input type="file" id="folderInput" webkitdirectory multiple style="display:none" onchange="handleFolderUpload(event)">
      </div>
    </aside>

    <section class="editor-panel">
      <div class="file-header" id="fileHeader">No file selected</div>
      <div class="editor-container" id="editorContainer">
        <div class="empty-state" id="emptyState">
          <h2>&#128274; LivePaste</h2>
          <p>E2E encrypted real-time code sharing. Upload a folder or create a file to get started.</p>
        </div>
        <div id="editorWrapper" class="hidden" style="height:100%"></div>
        <div class="diff-view hidden" id="diffView"></div>
      </div>
    </section>
  </main>

  <div id="addFileModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddFileModal()">
    <div class="modal">
      <h3>Add New File</h3>
      <input type="text" id="newFilePath" placeholder="path/to/file.js" onkeydown="if(event.key==='Enter')createNewFile()">
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddFileModal()">Cancel</button>
        <button class="btn" onclick="createNewFile()">Create</button>
      </div>
    </div>
  </div>

  <div id="addDirModal" class="modal-overlay hidden" onclick="if(event.target===this)hideAddDirModal()">
    <div class="modal">
      <h3>Add New Directory</h3>
      <input type="text" id="newDirPath" placeholder="path/to/directory" onkeydown="if(event.key==='Enter')createNewDir()">
      <p style="font-size:0.75rem;color:var(--muted);margin-top:0.5rem">Creates an empty .gitkeep file in the directory</p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideAddDirModal()">Cancel</button>
        <button class="btn" onclick="createNewDir()">Create</button>
      </div>
    </div>
  </div>

  <div id="passwordModal" class="modal-overlay hidden">
    <div class="modal">
      <h3 id="passwordModalTitle">Enter Room Password</h3>
      <input type="password" id="passwordInput" placeholder="Password" onkeydown="if(event.key==='Enter')submitPassword()">
      <p id="passwordError" style="color:var(--accent);font-size:0.875rem;margin-bottom:1rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn" onclick="submitPassword()">Enter</button>
      </div>
    </div>
  </div>

  <div id="setPasswordModal" class="modal-overlay hidden" onclick="if(event.target===this)hideSetPasswordModal()">
    <div class="modal">
      <h3>Set Room Password</h3>
      <p style="font-size:0.875rem;color:var(--muted);margin-bottom:1rem">Protect this room with a password. Others will need it to access.</p>
      <input type="password" id="setPasswordInput" placeholder="New password (min 4 chars)" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <input type="password" id="setPasswordConfirm" placeholder="Confirm password" style="margin-top:0.5rem" onkeydown="if(event.key==='Enter')setRoomPassword()">
      <p id="setPasswordError" style="color:var(--accent);font-size:0.875rem;margin-top:0.5rem;display:none"></p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="hideSetPasswordModal()">Cancel</button>
        <button class="btn" onclick="setRoomPassword()">Set Password</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/go/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/rust/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/ruby/ruby.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/php/php.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/swift/swift.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/yaml/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
  <script>
    const roomId = window.location.pathname.split('/').pop();
    let encryptionKey = null;
    let cryptoKey = null;
    let version = 0;
    let files = [];
    let changesets = [];
    let selectedFile = null;
    let dirHandle = null;
    let isPolling = false;
    let saveTimeout = null;
    let lastActivityTime = 0;
    const POLLING_PAUSE_MS = 2000; // Pause polling for 2s after typing
    let cmEditor = null; // CodeMirror instance
    let roomPassword = sessionStorage.getItem('room_password_' + roomId) || '';
    let hasPassword = false;

    async function initEncryption() {
      const fragment = window.location.hash.slice(1);
      if (fragment && fragment.length >= 32) {
        encryptionKey = fragment;
      } else {
        const keyBytes = crypto.getRandomValues(new Uint8Array(32));
        encryptionKey = btoa(String.fromCharCode(...keyBytes)).replace(/[+\/=]/g, c =>
          c === '+' ? '-' : c === '/' ? '_' : ''
        ).slice(0, 43);
        window.location.hash = encryptionKey;
      }
      const keyData = Uint8Array.from(atob(encryptionKey.replace(/-/g, '+').replace(/_/g, '/') + '='), c => c.charCodeAt(0));
      cryptoKey = await crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt']);
      document.getElementById('roomUrl').textContent = window.location.href;
    }

    async function encrypt(plaintext) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(plaintext);
      const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, encoded);
      const combined = new Uint8Array(iv.length + ciphertext.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(ciphertext), iv.length);
      // Convert to base64 in chunks to avoid stack overflow
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < combined.length; i += chunkSize) {
        binary += String.fromCharCode(...combined.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }

    async function decrypt(base64) {
      if (!base64) return '';
      try {
        const data = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
        const iv = data.slice(0, 12);
        const ciphertext = data.slice(12);
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext);
        return new TextDecoder().decode(plaintext);
      } catch (e) {
        console.error('Decryption failed:', e);
        return '[Decryption Error]';
      }
    }

    // Hash path for deterministic lookups (SHA-256)
    async function hashPath(path) {
      const encoded = new TextEncoder().encode(path);
      const hashBuffer = await crypto.subtle.digest('SHA-256', encoded);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    const SYNCABLE_EXT = new Set(['.js','.ts','.jsx','.tsx','.mjs','.cjs','.py','.java','.kt','.go','.rs','.rb','.php','.swift','.c','.cpp','.h','.cs','.lua','.sh','.bash','.json','.yaml','.yml','.toml','.xml','.html','.htm','.css','.scss','.sass','.md','.mdx','.txt','.sql','.vue','.svelte','.env','.gitignore','.dockerfile']);
    const NEVER_SYNC_EXT = new Set(['.jar','.exe','.dll','.so','.o','.a','.pyc','.wasm','.zip','.tar','.gz','.rar','.7z','.png','.jpg','.jpeg','.gif','.ico','.svg','.webp','.mp3','.mp4','.wav','.avi','.mov','.woff','.woff2','.ttf','.otf','.pdf','.doc','.docx','.xls','.xlsx','.ppt','.db','.sqlite','.pem','.key','.crt']);
    const NEVER_SYNC_DIRS = new Set(['node_modules','.git','dist','build','out','target','__pycache__','.next','vendor','venv','.venv','coverage','.idea','.vscode']);

    // Simple gitignore pattern matcher
    let gitignorePatterns = [];

    function parseGitignore(content) {
      const patterns = [];
      for (const line of content.split('\n')) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) continue;
        try {
          let pattern = trimmed;
          let isNegation = pattern.startsWith('!');
          if (isNegation) pattern = pattern.slice(1);
          let isDir = pattern.endsWith('/');
          if (isDir) pattern = pattern.slice(0, -1);
          // Escape regex special chars
          pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          // Convert glob patterns back
          pattern = pattern.replace(/\\\*\\\*/g, '.*');
          pattern = pattern.replace(/\\\*/g, '[^/]*');
          pattern = pattern.replace(/\\\?/g, '.');
          // Handle patterns starting with /
          if (pattern.startsWith('\\/')) {
            pattern = '^' + pattern.slice(2);
          } else {
            pattern = '(^|/)' + pattern;
          }
          if (isDir) pattern += '(/|$)';
          else pattern += '($|/)';
          patterns.push({ regex: new RegExp(pattern), isNegation, isDir });
        } catch (e) {
          console.warn('Invalid gitignore pattern:', trimmed, e);
        }
      }
      return patterns;
    }

    function isGitignored(path) {
      let ignored = false;
      for (const { regex, isNegation } of gitignorePatterns) {
        if (regex.test(path)) {
          ignored = !isNegation;
        }
      }
      return ignored;
    }

    function getExtension(filename) {
      const parts = filename.split('.');
      return parts.length > 1 ? '.' + parts.pop().toLowerCase() : '';
    }

    function isInIgnoredDir(path) {
      const parts = path.split('/');
      return parts.some(p => NEVER_SYNC_DIRS.has(p));
    }

    function isSyncable(path, content) {
      if (isInIgnoredDir(path)) return false;
      const filename = path.split('/').pop();
      if (filename === '.DS_Store' || filename === 'Thumbs.db') return false;
      if (isGitignored(path)) return false;
      const ext = getExtension(path);
      if (NEVER_SYNC_EXT.has(ext)) return false;
      if (SYNCABLE_EXT.has(ext)) return true;
      if (content && typeof content === 'string') {
        // Check for binary content by looking for control characters
        const sample = content.slice(0, 8000);
        let controlCount = 0;
        for (let i = 0; i < sample.length; i++) {
          const code = sample.charCodeAt(i);
          if ((code >= 0 && code <= 8) || code === 11 || code === 12 || (code >= 14 && code <= 31)) {
            controlCount++;
          }
        }
        if (controlCount / Math.min(content.length, 8000) > 0.1) return false;
      }
      return true;
    }

    function detectLanguage(filename) {
      const ext = getExtension(filename);
      // CodeMirror mode names
      const map = {
        '.js': 'javascript', '.mjs': 'javascript', '.cjs': 'javascript', '.jsx': 'javascript',
        '.ts': 'text/typescript', '.tsx': 'text/typescript',
        '.py': 'python',
        '.java': 'text/x-java', '.kt': 'text/x-kotlin',
        '.cs': 'text/x-csharp', '.cpp': 'text/x-c++src', '.c': 'text/x-csrc', '.h': 'text/x-c++hdr',
        '.go': 'go', '.rs': 'rust', '.rb': 'ruby', '.php': 'php',
        '.swift': 'swift', '.sql': 'sql',
        '.html': 'htmlmixed', '.htm': 'htmlmixed',
        '.css': 'css', '.scss': 'css',
        '.json': 'application/json',
        '.yaml': 'yaml', '.yml': 'yaml',
        '.md': 'markdown', '.sh': 'shell', '.bash': 'shell',
        '.xml': 'xml', '.svg': 'xml'
      };
      return map[ext] || 'text/plain';
    }

    // Hash password before sending (Client-side protection)
    async function hashPassword(password) {
      if (!password) return '';
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // API fetch with password header
    async function apiFetch(url, options = {}) {
      const headers = { ...options.headers };
      if (roomPassword) {
        headers['X-Room-Password'] = roomPassword;
      }
      const res = await fetch(url, { ...options, headers });
      if (res.status === 401) {
        const data = await res.json();
        if (data.password_required) {
          showPasswordModal();
          throw new Error('Password required');
        }
      }
      return res;
    }

    async function fetchRoomState() {
      const res = await apiFetch('/api/room/' + roomId);
      if (!res.ok) throw new Error('Failed to fetch room');
      return res.json();
    }

    async function checkRoomInfo() {
      const res = await fetch('/api/room/' + roomId + '/info');
      if (!res.ok) throw new Error('Failed to get room info');
      return res.json();
    }

    async function saveFile(path, content, isSyncableFile) {
      if (isSyncableFile === undefined) isSyncableFile = true;
      const res = await apiFetch('/api/room/' + roomId + '/files', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          path_hash: await hashPath(path),
          path_encrypted: await encrypt(path),
          content_encrypted: isSyncableFile ? await encrypt(content) : null,
          is_syncable: isSyncableFile,
          size_bytes: isSyncableFile ? null : content.length
        })
      });
      if (!res.ok) throw new Error('Failed to save file');
      return res.json();
    }

    async function deleteFile(fileId) {
      const res = await apiFetch('/api/room/' + roomId + '/files/' + fileId, { method: 'DELETE' });
      if (!res.ok) throw new Error('Failed to delete file');
    }

    // Stealth chunked sync - designed for enterprise proxy compatibility
    const CHUNK_TARGET_SIZE = 150 * 1024; // ~150KB per chunk (well under DLP thresholds)
    const CHUNK_MIN_DELAY = 200;  // Min delay between chunks (ms)
    const CHUNK_MAX_DELAY = 800;  // Max delay between chunks (ms)

    // Generate random delay to mimic human interaction patterns
    function randomDelay() {
      return CHUNK_MIN_DELAY + Math.random() * (CHUNK_MAX_DELAY - CHUNK_MIN_DELAY);
    }

    // Generate low-entropy padding to balance high-entropy encrypted content
    function generateMetadata() {
      const actions = ['sync', 'update', 'save', 'upload', 'push', 'commit'];
      const sources = ['editor', 'browser', 'client', 'app', 'web', 'ui'];
      return {
        action: actions[Math.floor(Math.random() * actions.length)],
        source: sources[Math.floor(Math.random() * sources.length)],
        client_version: '1.0.0',
        platform: navigator.platform || 'web',
        locale: navigator.language || 'en-US',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${window.screen.width}x${window.screen.height}`,
        timestamp: new Date().toISOString(),
        user_agent_hash: btoa(navigator.userAgent.slice(0, 20)).slice(0, 12)
      };
    }

    // Generate unique identifiers that look like standard API fields
    function generateRequestId() {
      return 'req_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    }

    function generateClientId() {
      let clientId = sessionStorage.getItem('livepaste_client_id');
      if (!clientId) {
        clientId = 'client_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 10);
        sessionStorage.setItem('livepaste_client_id', clientId);
      }
      return clientId;
    }

    async function syncFiles(fileList) {
      // Encrypt all files first (CPU-bound, do in batches)
      const ENCRYPT_BATCH_SIZE = 30;
      const encrypted = [];

      for (let i = 0; i < fileList.length; i += ENCRYPT_BATCH_SIZE) {
        const batch = fileList.slice(i, i + ENCRYPT_BATCH_SIZE);
        const batchEncrypted = await Promise.all(batch.map(async f => ({
          path_hash: await hashPath(f.path),
          path_encrypted: await encrypt(f.path),
          content_encrypted: f.is_syncable ? await encrypt(f.content) : null,
          is_syncable: f.is_syncable,
          size_bytes: f.is_syncable ? null : f.size
        })));
        encrypted.push(...batchEncrypted);
        console.log(`Encrypted ${Math.min(i + ENCRYPT_BATCH_SIZE, fileList.length)}/${fileList.length} files`);
      }

      // Calculate chunk sizes based on payload size, not file count
      const chunks = [];
      let currentChunk = [];
      let currentSize = 0;

      for (const file of encrypted) {
        const fileSize = JSON.stringify(file).length;
        if (currentSize + fileSize > CHUNK_TARGET_SIZE && currentChunk.length > 0) {
          chunks.push(currentChunk);
          currentChunk = [];
          currentSize = 0;
        }
        currentChunk.push(file);
        currentSize += fileSize;
      }
      if (currentChunk.length > 0) {
        chunks.push(currentChunk);
      }

      console.log(`Split into ${chunks.length} chunks for upload`);

      // Start sync session
      const clientId = generateClientId();
      const beginRes = await apiFetch('/api/room/' + roomId + '/sync/begin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          client_id: clientId,
          total_chunks: chunks.length,
          total_files: encrypted.length,
          metadata: generateMetadata()
        })
      });

      if (!beginRes.ok) throw new Error('Failed to begin sync');
      const { session_id } = await beginRes.json();

      // Upload chunks with random delays
      for (let i = 0; i < chunks.length; i++) {
        if (i > 0) {
          // Random delay between chunks to mimic human behavior
          await new Promise(r => setTimeout(r, randomDelay()));
        }

        const chunkRes = await apiFetch('/api/room/' + roomId + '/sync/chunk', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id,
            chunk_index: i,
            files: chunks[i],
            client_timestamp: new Date().toISOString(),
            request_id: generateRequestId(),
            metadata: generateMetadata()
          })
        });

        if (!chunkRes.ok) throw new Error(`Failed to upload chunk ${i + 1}/${chunks.length}`);

        const progress = Math.round(((i + 1) / chunks.length) * 100);
        console.log(`Uploaded chunk ${i + 1}/${chunks.length} (${progress}%)`);
        showToast(`Syncing... ${progress}%`);
      }

      // Small delay before completing
      await new Promise(r => setTimeout(r, randomDelay()));

      // Complete sync
      const completeRes = await apiFetch('/api/room/' + roomId + '/sync/complete', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_id,
          client_checksum: encrypted.length.toString(),
          finalize: true,
          metadata: generateMetadata()
        })
      });

      if (!completeRes.ok) throw new Error('Failed to complete sync');
      return completeRes.json();
    }

    // Short polling - check version every 2 seconds
    let pollInterval = null;

    async function poll() {
      if (isPolling) return;
      
      // Skip polling if user is actively typing to prevent overwrites/jank
      if (Date.now() - lastActivityTime < POLLING_PAUSE_MS) return;

      isPolling = true;
      try {
        const res = await apiFetch('/api/room/' + roomId + '/version');
        if (!res.ok) throw new Error('Version check failed');
        const { version: serverVersion } = await res.json();

        if (serverVersion > version) {
          // Version changed, fetch full state
          const stateRes = await apiFetch('/api/room/' + roomId);
          if (!stateRes.ok) throw new Error('State fetch failed');
          const state = await stateRes.json();
          await applyState(state);
        }
        setStatus(true);
      } catch (e) {
        if (e.message === 'Password required') {
          stopPolling();
        } else {
          console.error('Poll error:', e);
          setStatus(false);
        }
      } finally {
        isPolling = false;
      }
    }

    function stopPolling() {
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
    }

    function startPolling() {
      if (pollInterval) clearInterval(pollInterval);
      pollInterval = setInterval(poll, 2000);
    }

    async function applyState(state) {
      version = state.version;
      document.getElementById('versionBadge').textContent = version;
      files = await Promise.all(state.files.map(async f => ({
        ...f,
        path: await decrypt(f.path_encrypted),
        content: f.is_syncable ? await decrypt(f.content_encrypted) : null
      })));
      changesets = await Promise.all((state.changesets || []).map(async cs => ({
        ...cs,
        author: await decrypt(cs.author_encrypted),
        message: await decrypt(cs.message_encrypted),
        changes: await Promise.all((cs.changes || []).map(async ch => ({
          ...ch,
          file_path: await decrypt(ch.file_path_encrypted),
          old_content: ch.old_content_encrypted ? await decrypt(ch.old_content_encrypted) : '',
          new_content: await decrypt(ch.new_content_encrypted),
          diff: ch.diff_encrypted ? await decrypt(ch.diff_encrypted) : ''
        })))
      })));
      renderFileTree();
      updateChangesetBanner();
      if (selectedFile) {
        const stillExists = files.find(f => f.path === selectedFile.path);
        if (stillExists) {
          selectFile(stillExists);
        } else {
          selectedFile = null;
          showEmptyState();
        }
      }
    }

    let fileSearchQuery = '';
    const collapsedFolders = new Set();

    function filterFiles() {
      fileSearchQuery = document.getElementById('fileSearch').value.toLowerCase();
      renderFileTree();
    }

    function toggleFolder(path) {
      if (collapsedFolders.has(path)) {
        collapsedFolders.delete(path);
      } else {
        collapsedFolders.add(path);
      }
      renderFileTree();
    }

    function getAllFolderPaths() {
      const folders = new Set();
      for (const file of files) {
        const parts = file.path.split('/');
        let path = '';
        for (let i = 0; i < parts.length - 1; i++) {
          path = path ? path + '/' + parts[i] : parts[i];
          folders.add(path);
        }
      }
      return folders;
    }

    function expandAll() {
      collapsedFolders.clear();
      renderFileTree();
    }

    function collapseAll() {
      const allFolders = getAllFolderPaths();
      for (const folder of allFolders) {
        collapsedFolders.add(folder);
      }
      renderFileTree();
    }

    function renderFileTree() {
      const query = fileSearchQuery;
      const filteredFiles = query
        ? files.filter(f => f.path.toLowerCase().includes(query))
        : files;

      const tree = {};
      for (const file of filteredFiles) {
        const parts = file.path.split('/');
        let current = tree;
        for (let i = 0; i < parts.length - 1; i++) {
          if (!current[parts[i]]) current[parts[i]] = { _isDir: true };
          current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = file;
      }
      function renderNode(node, name, path) {
        path = path || '';
        const fullPath = path ? path + '/' + name : name;
        if (node._isDir) {
          const children = Object.entries(node).filter(e => e[0] !== '_isDir');
          // Auto-expand if only contains one subfolder and no files
          const hasOnlyOneSubfolder = children.length === 1 && children[0][1]._isDir;
          const isCollapsed = collapsedFolders.has(fullPath) && !hasOnlyOneSubfolder;
          const icon = isCollapsed ? '&#128193;' : '&#128194;';
          return `<div class="tree-item folder" onclick="toggleFolder('${fullPath}')"><span class="icon">${icon}</span><span class="name">${name}</span></div><div class="tree-children ${isCollapsed ? 'hidden' : ''}">${children.map(e => renderNode(e[1], e[0], fullPath)).join('')}</div>`;
        }
        const file = node;
        const isSelected = selectedFile && selectedFile.id === file.id;
        const hasPendingChange = changesets.some(cs => cs.changes.some(ch => ch.file_path === file.path && ch.status === 'pending'));
        return `<div class="tree-item ${isSelected ? 'selected' : ''} ${!file.is_syncable ? 'non-syncable' : ''}" onclick="selectFileById('${file.id}')"><span class="icon">${file.is_syncable ? '&#128196;' : '&#9675;'}</span><span class="name">${name}${hasPendingChange ? ' [!]' : ''}</span>${!file.is_syncable && file.size_bytes ? `<span class="size">${formatSize(file.size_bytes)}</span>` : ''}</div>`;
      }
      const rootEntries = Object.entries(tree);
      const fileTreeEl = document.getElementById('fileTree');
      const scrollTop = fileTreeEl.scrollTop; // Preserve scroll position
      fileTreeEl.innerHTML = rootEntries.length
        ? rootEntries.map(e => renderNode(e[1], e[0])).join('')
        : `<div style="padding:1rem;color:var(--muted);text-align:center">${query ? 'No matches' : 'No files yet'}</div>`;
      fileTreeEl.scrollTop = scrollTop; // Restore scroll position
    }

    function formatSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function selectFileById(id) {
      const file = files.find(f => f.id === id);
      if (file) selectFile(file);
    }

    function selectFile(file) {
      selectedFile = file;
      renderFileTree();
      document.getElementById('fileHeader').textContent = file.path;
      document.getElementById('emptyState').classList.add('hidden');
      const pendingChange = changesets.flatMap(cs => cs.changes).find(
        ch => ch.file_path === file.path && ch.status === 'pending'
      );
      if (pendingChange) {
        showDiffView(pendingChange);
      } else if (file.is_syncable) {
        showEditor(file);
      } else {
        showNonSyncable(file);
      }
    }

    function showEditor(file) {
      document.getElementById('diffView').classList.add('hidden');
      const wrapper = document.getElementById('editorWrapper');
      wrapper.classList.remove('hidden');

      const mode = detectLanguage(file.path);
      const newContent = file.content || '';

      if (!cmEditor) {
        // Create CodeMirror instance
        cmEditor = CodeMirror(wrapper, {
          value: newContent,
          mode: mode,
          theme: 'material-darker',
          lineNumbers: true,
          tabSize: 2,
          indentWithTabs: false,
          lineWrapping: true,
          matchBrackets: true,
          autoCloseBrackets: true
        });
        cmEditor.on('change', handleEditorChange);
      } else {
        // Only update if content actually changed (preserve scroll/cursor otherwise)
        const currentContent = cmEditor.getValue();
        if (currentContent !== newContent) {
          const scrollInfo = cmEditor.getScrollInfo();
          const cursor = cmEditor.getCursor();
          cmEditor.setValue(newContent);
          cmEditor.scrollTo(scrollInfo.left, scrollInfo.top);
          cmEditor.setCursor(cursor);
        }
        cmEditor.setOption('mode', mode);
      }
      cmEditor.refresh();
    }

    function showDiffView(change) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      const diff = change.diff || Diff.createPatch(change.file_path, change.old_content, change.new_content);
      const lines = diff.split('\n').map(line => {
        let cls = '';
        if (line.charAt(0) === '+' && line.substring(0,3) !== '+++') cls = 'added';
        else if (line.charAt(0) === '-' && line.substring(0,3) !== '---') cls = 'removed';
        else if (line.substring(0,2) === '@@') cls = 'header';
        return `<div class="diff-line ${cls}">${escapeHtml(line)}</div>`;
      }).join('');
      document.getElementById('diffView').innerHTML = `<div class="change-card"><div class="change-card-header"><span class="path">${change.file_path}</span><div class="change-card-actions"><button class="btn" onclick="acceptChange('${change.id}')">&check; Accept</button><button class="btn btn-secondary" onclick="rejectChange('${change.id}')">&times; Reject</button></div></div>${lines}</div>`;
    }

    function showNonSyncable(file) {
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.remove('hidden');
      document.getElementById('diffView').innerHTML = `<div style="padding:2rem;text-align:center;color:var(--muted)"><p>&#9675; This file is only available on the source machine.</p><p style="margin-top:0.5rem">Size: ${formatSize(file.size_bytes || 0)}</p></div>`;
    }

    function showEmptyState() {
      document.getElementById('fileHeader').textContent = 'No file selected';
      document.getElementById('emptyState').classList.remove('hidden');
      document.getElementById('editorWrapper').classList.add('hidden');
      document.getElementById('diffView').classList.add('hidden');
    }

    function updateChangesetBanner() {
      const pending = changesets.filter(cs => cs.status === 'pending');
      const banner = document.getElementById('changesetBanner');
      if (pending.length > 0) {
        const cs = pending[0];
        const changeCount = cs.changes.filter(ch => ch.status === 'pending').length;
        document.getElementById('changesetMessage').textContent = `${cs.author || 'Someone'} proposed ${changeCount} change(s): "${cs.message || 'No message'}"`;
        banner.classList.remove('hidden');
      } else {
        banner.classList.add('hidden');
      }
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function setStatus(online) {
      const dot = document.getElementById('statusDot');
      const text = document.getElementById('statusText');
      if (online) {
        dot.classList.remove('offline');
        text.textContent = 'Online';
      } else {
        dot.classList.add('offline');
        text.textContent = 'Reconnecting...';
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function handleEditorChange() {
      if (!selectedFile || !selectedFile.is_syncable || !cmEditor) return;
      
      lastActivityTime = Date.now();
      
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(async () => {
        const content = cmEditor.getValue();
        if (content !== selectedFile.content) {
          try {
            await saveFile(selectedFile.path, content);
            selectedFile.content = content;
            showToast('Saved');
          } catch (e) {
            showToast('Save failed', 'error');
          }
        }
      }, 500);
    }


    function copyCode() {
      if (selectedFile) {
        navigator.clipboard.writeText(selectedFile.content || '');
        showToast('Copied to clipboard');
      }
    }

    function copyRoomUrl() {
      navigator.clipboard.writeText(window.location.href);
      showToast('URL copied to clipboard');
    }

    async function downloadAll() {
      const zip = new JSZip();
      for (const file of files) {
        if (file.is_syncable && file.content) {
          zip.file(file.path, file.content);
        }
      }
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `livepaste-${roomId}.zip`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showAddFileModal() {
      document.getElementById('addFileModal').classList.remove('hidden');
      document.getElementById('newFilePath').focus();
    }

    function hideAddFileModal() {
      document.getElementById('addFileModal').classList.add('hidden');
      document.getElementById('newFilePath').value = '';
    }

    async function createNewFile() {
      const path = document.getElementById('newFilePath').value.trim();
      if (!path) return;
      try {
        await saveFile(path, '');
        hideAddFileModal();
        showToast('File created');
      } catch (e) {
        showToast('Failed to create file', 'error');
      }
    }

    function uploadFolder() {
      if ('showDirectoryPicker' in window) {
        uploadFolderNative();
      } else {
        document.getElementById('folderInput').click();
      }
    }

    async function uploadFolderNative() {
      try {
        dirHandle = await window.showDirectoryPicker();
        document.getElementById('saveToDiskBtn').style.display = 'block';

        // Try to read .gitignore first
        gitignorePatterns = [];
        try {
          const gitignoreHandle = await dirHandle.getFileHandle('.gitignore');
          const gitignoreFile = await gitignoreHandle.getFile();
          const gitignoreContent = await gitignoreFile.text();
          gitignorePatterns = parseGitignore(gitignoreContent);
          console.log(`Loaded ${gitignorePatterns.length} gitignore patterns`);
        } catch (e) {
          console.log('No .gitignore found, continuing without it');
        }

        const fileList = [];
        let skippedCount = 0;
        async function readDir(handle, path = '') {
          for await (const entry of handle.values()) {
            const entryPath = path ? path + '/' + entry.name : entry.name;
            try {
              if (entry.kind === 'directory') {
                if (!NEVER_SYNC_DIRS.has(entry.name) && !isGitignored(entryPath + '/')) {
                  await readDir(entry, entryPath);
                } else {
                  skippedCount++;
                }
              } else {
                const syncable = isSyncable(entryPath, null);
                if (syncable) {
                  const file = await entry.getFile();
                  const content = await file.text();
                  fileList.push({ path: entryPath, content, is_syncable: true });
                } else {
                  skippedCount++;
                }
              }
            } catch (fileErr) {
              console.warn(`Skipping ${entryPath}: ${fileErr.message}`);
              skippedCount++;
            }
          }
        }
        console.log('Starting folder scan...');
        await readDir(dirHandle);
        console.log(`Scan complete: ${fileList.length} files to upload, ${skippedCount} skipped`);

        if (fileList.length === 0) {
          showToast('No syncable files found', 'error');
          return;
        }

        showToast(`Syncing ${fileList.length} files...`);
        const newState = await syncFiles(fileList);
        await applyState(newState);
        showToast(`Uploaded ${fileList.length} files (${skippedCount} skipped)`);
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Folder upload error:', e);
          showToast(`Upload failed: ${e.message}`, 'error');
        }
      }
    }

    async function handleFolderUpload(event) {
      const inputFiles = event.target.files;
      if (!inputFiles.length) return;
      const fileList = [];
      for (const file of inputFiles) {
        const path = file.webkitRelativePath || file.name;
        if (isInIgnoredDir(path)) continue;
        const syncable = isSyncable(path, null);
        if (syncable) {
          const content = await file.text();
          fileList.push({ path, content, is_syncable: true });
        } else {
          fileList.push({ path, content: '', is_syncable: false, size: file.size });
        }
      }
      const newState = await syncFiles(fileList);
      await applyState(newState);
      showToast(`Uploaded ${fileList.length} files`);
      event.target.value = '';
    }

    async function saveToDisk() {
      if (!dirHandle) return;
      try {
        for (const file of files) {
          if (!file.is_syncable || !file.content) continue;
          const parts = file.path.split('/');
          let currentHandle = dirHandle;
          for (let i = 0; i < parts.length - 1; i++) {
            currentHandle = await currentHandle.getDirectoryHandle(parts[i], { create: true });
          }
          const fileHandle = await currentHandle.getFileHandle(parts[parts.length - 1], { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(file.content);
          await writable.close();
        }
        showToast('Saved to disk');
      } catch (e) {
        console.error('Save to disk error:', e);
        showToast('Save failed', 'error');
      }
    }

    async function acceptAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/accept`, { method: 'POST' });
        showToast('Changes accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectAllChanges() {
      const pending = changesets.find(cs => cs.status === 'pending');
      if (!pending) return;
      try {
        await apiFetch(`/api/room/${roomId}/changesets/${pending.id}/reject`, { method: 'POST' });
        showToast('Changes rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    async function acceptChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/accept`, { method: 'POST' });
        showToast('Change accepted');
      } catch (e) {
        showToast('Failed to accept', 'error');
      }
    }

    async function rejectChange(changeId) {
      try {
        await apiFetch(`/api/room/${roomId}/changes/${changeId}/reject`, { method: 'POST' });
        showToast('Change rejected');
      } catch (e) {
        showToast('Failed to reject', 'error');
      }
    }

    // Sidebar resize functionality
    function initSidebarResize() {
      const sidebar = document.getElementById('sidebar');
      const resizer = document.getElementById('sidebarResize');
      let isResizing = false;

      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        resizer.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 150 && newWidth <= 600) {
          sidebar.style.width = newWidth + 'px';
        }
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          resizer.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
        }
      });
    }

    // Password modal functions
    function showPasswordModal() {
      document.getElementById('passwordModal').classList.remove('hidden');
      document.getElementById('passwordInput').focus();
      document.getElementById('passwordError').style.display = 'none';
    }

    function hidePasswordModal() {
      document.getElementById('passwordModal').classList.add('hidden');
      document.getElementById('passwordInput').value = '';
    }

    async function submitPassword() {
      const passwordInput = document.getElementById('passwordInput').value;
      if (!passwordInput) return;

      try {
        const passwordHash = await hashPassword(passwordInput);
        const res = await fetch('/api/room/' + roomId + '/verify-password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hidePasswordModal();
          // Retry loading the room
          const state = await fetchRoomState();
          await applyState(state);
          startPolling();
          showToast('Access granted');
        } else {
          document.getElementById('passwordError').textContent = 'Incorrect password';
          document.getElementById('passwordError').style.display = 'block';
        }
      } catch (e) {
        document.getElementById('passwordError').textContent = 'Error verifying password';
        document.getElementById('passwordError').style.display = 'block';
      }
    }

    function showSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.remove('hidden');
      document.getElementById('setPasswordInput').focus();
      document.getElementById('setPasswordError').style.display = 'none';
    }

    function hideSetPasswordModal() {
      document.getElementById('setPasswordModal').classList.add('hidden');
      document.getElementById('setPasswordInput').value = '';
      document.getElementById('setPasswordConfirm').value = '';
    }

    async function setRoomPassword() {
      const password = document.getElementById('setPasswordInput').value;
      const confirm = document.getElementById('setPasswordConfirm').value;
      const errorEl = document.getElementById('setPasswordError');

      if (password.length < 4) {
        errorEl.textContent = 'Password must be at least 4 characters';
        errorEl.style.display = 'block';
        return;
      }

      if (password !== confirm) {
        errorEl.textContent = 'Passwords do not match';
        errorEl.style.display = 'block';
        return;
      }

      try {
        const passwordHash = await hashPassword(password);
        const res = await fetch('/api/room/' + roomId + '/password', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ password: passwordHash, current_password: roomPassword })
        });

        if (res.ok) {
          roomPassword = passwordHash;
          sessionStorage.setItem('room_password_' + roomId, roomPassword);
          hasPassword = true;
          updatePasswordUI();
          hideSetPasswordModal();
          showToast('Password set successfully');
        } else {
          const data = await res.json();
          errorEl.textContent = data.error || 'Failed to set password';
          errorEl.style.display = 'block';
        }
      } catch (e) {
        errorEl.textContent = 'Error setting password';
        errorEl.style.display = 'block';
      }
    }

    async function confirmKillRoom() {
      if (confirm('Are you sure you want to PERMANENTLY delete this room and all its files? This cannot be undone.')) {
        try {
          const res = await apiFetch('/api/room/' + roomId, { method: 'DELETE' });
          if (res.ok) {
            alert('Room deleted.');
            window.location.href = '/';
          } else {
            showToast('Failed to delete room', 'error');
          }
        } catch (e) {
          showToast('Error deleting room', 'error');
        }
      }
    }

    function updatePasswordUI() {
      const statusEl = document.getElementById('passwordStatus');
      const btnEl = document.getElementById('passwordBtn');
      if (hasPassword) {
        statusEl.style.display = 'inline';
        statusEl.title = 'Room is password protected';
        btnEl.title = 'Change room password';
      } else {
        statusEl.style.display = 'none';
        btnEl.title = 'Set room password';
      }
    }

    // Directory creation functions
    function showAddDirModal() {
      document.getElementById('addDirModal').classList.remove('hidden');
      document.getElementById('newDirPath').focus();
    }

    function hideAddDirModal() {
      document.getElementById('addDirModal').classList.add('hidden');
      document.getElementById('newDirPath').value = '';
    }

    async function createNewDir() {
      let path = document.getElementById('newDirPath').value.trim();
      if (!path) return;
      // Ensure path doesn't end with /
      if (path.endsWith('/')) path = path.slice(0, -1);
      // Create .gitkeep file in the directory
      const gitkeepPath = path + '/.gitkeep';
      try {
        await saveFile(gitkeepPath, '');
        hideAddDirModal();
        showToast('Directory created');
      } catch (e) {
        showToast('Failed to create directory', 'error');
      }
    }

    async function init() {
      await initEncryption();

      // Check if room has password
      try {
        const info = await checkRoomInfo();
        hasPassword = info.has_password;
        updatePasswordUI();

        if (hasPassword && !roomPassword) {
          // Need password - show modal
          showPasswordModal();
          return;
        }
      } catch (e) {
        console.error('Failed to check room info:', e);
      }

      try {
        const state = await fetchRoomState();
        hasPassword = state.has_password || false;
        updatePasswordUI();
        await applyState(state);
        initSidebarResize();
        startPolling();
      } catch (e) {
        if (e.message === 'Password required') {
          showPasswordModal();
        } else {
          console.error('Init error:', e);
          showToast('Failed to load room', 'error');
        }
      }
    }

    init().catch(console.error);
  </script>
</body>
</html>
